<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/workshop/component---src-layouts-index-js-1e3fc81ebbae08575bfd.js" as="script"/><link rel="preload" href="/workshop/component---src-templates-blog-post-js-46e2ca802238dc3d0766.js" as="script"/><link rel="preload" href="/workshop/path---rust-258af777f2459be8b0ac.js" as="script"/><link rel="preload" href="/workshop/app-fcd3bd8846658287ca1d.js" as="script"/><link rel="preload" href="/workshop/commons-99efdf1a76a6a156fb09.js" as="script"/><title data-react-helmet="true">Rust - My Blog</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style id="gatsby-inlined-css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:rgba(0,0,0,.8);font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt","kern"}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding:0}h1{font-size:2.25rem}h1,h2{margin-left:0;margin-right:0;margin-top:0;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{margin-left:0;margin-right:0;margin-top:0;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{margin-left:0;margin-right:0;margin-top:0;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{margin-left:0;margin-right:0;margin-top:0;padding:0}ol,ul{margin-left:1.45rem;margin-right:0;margin-top:0;padding:0;list-style-position:outside;list-style-image:none}dd,dl,p{margin-left:0;margin-right:0;margin-top:0;padding:0}figure{margin:0 0 1.45rem;padding-left:0;padding-right:0;padding-top:0}pre{padding:0;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}pre,table{margin-left:0;margin-right:0;margin-top:0}table{padding:0;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset{margin-left:0;margin-right:0}blockquote,fieldset{margin-top:0;padding:0}blockquote{margin-left:1.45rem;margin-right:1.45rem}form,hr,iframe,noscript{margin-left:0;margin-right:0;margin-top:0;padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px}address{margin-left:0;margin-right:0;margin-top:0;padding:0}b,dt,strong,th{font-weight:700}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:0;padding-top:.2em;padding-bottom:.2em}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="1179725362"><!-- react-empty: 2 --><div style="background:cornflowerblue;margin-bottom:0.6rem;" data-reactid="3"><div style="margin:0 auto;max-width:960px;padding:0.6rem 1.0875rem;" data-reactid="4"><h1 style="margin:0;font-size:1em;" data-reactid="5"><a style="color:white;text-decoration:none;" href="/workshop/" data-reactid="6">Nicolas&#x27;s workshop</a></h1></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0;" data-reactid="7"><div data-reactid="8"><!-- react-empty: 9 --><div data-reactid="10"><h1 data-reactid="11">Rust</h1><h3 data-reactid="12">February 06, 2022</h3><div data-reactid="13"><h2>Cargo commands</h2>
<p>Command to create a project:</p>
<pre><code class="language-bash">cargo new hello
</code></pre>
<p>You can compile and run the project now with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>This builds the project in a directory called <code>target/debug</code>.
To build the project in the <code>target/release</code> directory intended for prod, just run:</p>
<pre><code class="language-bash">cargo run --release
</code></pre>
<p>A good tip to improve the code with idiomatic rust coding hints/warnings is to run:</p>
<pre><code class="language-bash">cargo clippy
</code></pre>
<p>Here is a command to view the standard library in the default browser:</p>
<pre><code class="language-bash">rustup doc --std
</code></pre>
<h3>Coding modules</h3>
<p>Crates are about code sharing between projects while modules are about
code sharing within a project. </p>
<p>This can take place in a package library. This can be created with:</p>
<pre><code class="language-bash">cargo new todo --lib
</code></pre>
<p>Cargo modules is a useful tool to manage modules. It can be installed with:</p>
<pre><code class="language-bash">cargo install cargo-modules
</code></pre>
<p>Then, project's modules tree can be displayed with:</p>
<pre><code class="language-bash">cargo modules generate tree
</code></pre>
<p>The displayed tree can be refined with options:</p>
<pre><code class="language-bash">cargo modules generate tree --with-types
</code></pre>
<h2>Strings</h2>
<p>String slices refered to as <code>str</code>
are almost always handled in the shape of borrowed string slices <code>&#x26;str</code>.
See also the Rust documentation on <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">references and borrowing</a>.</p>
<p>A string literal stated
<code>let msg = "Hello ðŸŒŽ";</code>
is a borrowed string slice.</p>
<p>The other string type is String.
Data in a borrowed string slice cannot be modified
while data in a String can be modified.</p>
<p>A String can be obtained by applying the to_string() method on a
borrowed string slice:</p>
<pre><code>let msg = "abðŸŽ‰".to_string();
</code></pre>
<p>or else by passing the borrowed string slice to String::from:</p>
<pre><code>let msg = String::from("abðŸŽ‰");
</code></pre>
<p>Internally, a borrowed string slice is made up of a pointer to some byte and
a length. The length is the number of unicode characters in the string.</p>
<p>Bytes can be extracted from a borrowed string slice with the bytes() method: <code>word.bytes();</code></p>
<p>An iterator on unicode scalars can be built with <code>word.chars();</code></p>
<p>Additionally, an iterator on graphemes can be retrieved using a package called unicode-segmentation with:</p>
<p><code>graphemes(my_string, true)</code></p>
<p>A given item in the graphemes can then be accessed with by appending a statement like<code>.nth(3)</code></p>
<p>All of the helper methods to manipulate String objects are documented
<a href="https://doc.rust-lang.org/std/string/struct.String.html#method.bytes">here</a>.</p>
<p>A String can be converted into a &#x26;str with the <code>.as_str()</code> method.
It follows that string slices can manipulated in the shape of String objects
and the latter can be converted back into string slices with <code>as_str()</code>.
For instance two <code>&#x26;str</code> can be concatenated into a string c with:</p>
<pre><code class="language-bash">let a = "Hello";
let b = " World";
let c = format!("{}{}", a, b);
</code></pre>
<h2>String literals</h2>
<pre><code class="language-rust">let rust = "\x52\x75\x73\x74";
println!("{}", rust);
</code></pre>
<h2>Struct with impl</h2>
<pre><code class="language-rust">struct Square {
    width: u32,
    height: u32,
}

impl Square {
    fn area(&#x26;self) -> u32 {
        self.width * self.height
    }

    fn whats_my_width(&#x26;self) -> u32 {
        self.width
    }

    fn change_width(&#x26;mut self, new_width: u32){
        self.width = new_width;
    }
}
</code></pre>
<h2>Struct with Trait</h2>
<pre><code class="language-rust">#[derive(Debug)]
struct RedFox {
    enemy: bool,
    life: u32,
}

trait Noisy {
    fn get_noise(&#x26;self) -> &#x26;str;
}

impl Noisy for RedFox {
    fn get_noise(&#x26;self) -> &#x26;str { "Meow?" }
}

fn print_noise&#x3C;T: Noisy>(item: T) {
    println!("", item.get_noise());
}

impl Noisy for u8 {
    fn get_noise(&#x26;self) -> &#x26;str { "BYTE!" }
}

fn main() {
    print_noise(5_u8); // prints "BYTE!"
}
</code></pre>
<p>There are two other types of Struct. One is the tuple like Struct:</p>
<pre><code class="language-rust">struct Coordinates(i32, i32, i32);
</code></pre>
<p>The other is the unit like Struct which is useful when combined with Traits:</p>
<pre><code class="language-rust">struct UnitStruct;
</code></pre>
<h2>Utility Traits</h2>
<ul>
<li>The Drop Trait:</li>
</ul>
<pre><code class="language-rust">struct Course {
    headline: String,
    author: String,
}

impl Drop for Course {
    fn drop(&#x26;mut self) {
        println!("Dropping: {}", self.author);
    }
}

fn main() {
    let course1 = Course{ headline: String::from("Headline!"), author: String::from("Tyler"), };

    drop(course1);
}
</code></pre>
<ul>
<li>The Clone Trait which is for types that can make copies of themselves :</li>
</ul>
<pre><code class="language-rust">trait Clone: Sized {
    fn clone(&#x26;self) -> Self;
    fn clone_from(&#x26;mut self, source: &#x26;Self) {
        *self = source.clone()
    }
}
</code></pre>
<ul>
<li>
<p>Copy is a shallow Clone</p>
</li>
<li>
<p>From and Into, plus: TryFrom and TryInto</p>
</li>
</ul>
<p><code>fn into(self) -> T</code>: take self and returns a value of type T.</p>
<p><code>fn from(T) -> Self</code>: take a value of type T and returns self.</p>
<ul>
<li>Arithmetics: the Add Trait</li>
</ul>
<pre><code class="language-bash">use std::ops::Add;

#[derive(Debug)]
struct Point&#x3C;T> {
    x: T,
    y: T
}

fn main() {
    let coord = Point{ x: 5.0, y: 5.0 };
    let coord2 = Point{ x: 1.0, y: 2.0 };
    let sum = coord + coord2;
    println!("{:?}", sum);
}

impl&#x3C;T> Add for Point&#x3C;T>
    where
    T: Add&#x3C;Output = T> {
        type Output = Self;        
        fn add(self, rhs: Self) -> Self {
            Point {
                x: self.x + rhs.x,
                y: self.y + rhs.y,
            }
        }
    }
</code></pre>
<ul>
<li>
<p>Fn is a family of closures and functions that you can call multiple times without restrictions. It borrows values from the environment immutably. It includes all fn functions.</p>
</li>
<li>
<p>FnMut is a family of closures and functions that you can call multiple times if the closure itself is declared mut. It immutably borrows values.</p>
</li>
<li>
<p>FnOnce is a family of closures that can be called once if the caller owns the closure. The closure cannot take ownership of the same variables more than once.</p>
</li>
</ul>
<p>Therefore, every Fn meets the requirements for FnMut and every FnMut meets the requirements for FnOnce. It means that Fn is the most exclusive and the most powerful in this set of three Traits.</p>
<p>Examples: </p>
<ul>
<li>
<p>|| drop(v) FnOnce  ---> FnOnce</p>
</li>
<li>
<p>|args| v.contains(arg) ---> Fn</p>
</li>
<li>
<p>|args| v.push(arg)  ---> FnMut</p>
</li>
<li>
<p>Iterator</p>
</li>
</ul>
<h2>Lifetimes</h2>
<p>Every reference has a Lifetime. Most of the time, Lifetimes are implicit and inferred.</p>
<pre><code class="language-rust">fn longest&#x3C;'a>(x: &#x26;'a str, y: &#x26;'a str) -> &#x26;'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p>Syntax for lifetime in a struct is as follows:</p>
<pre><code class="language-rust">struct MyString&#x3C;'a> {
    text: &#x26;'a str
}
</code></pre>
<p>Here is an example of a variable defined with a static lifetime:</p>
<pre><code class="language-rust">let s: &#x26;'static str = "I have static lifetime";
</code></pre>
<h2>Vectors</h2>
<pre><code class="language-rust">let mut v: Vec&#x3C;i32> = Vec::new();
v.push(2);
v.push(4);
v.push(6);
let x = v.pop();    // x is 6
println("{}", v[1]);// prints "4"
let mut u = vec![2, 4, 6];
</code></pre>
<p>Other ways to instanciate vectors: </p>
<pre><code class="language-rust">let vect= Vec::&#x3C;i32>::with_capacity(2);
println!("{}", vect.capacity());

let v: Vec&#x3C;i32> = (0..5).collect();
println!("{:?}", v);
</code></pre>
<p>Vector API examples:</p>
<pre><code class="language-rust">let mut nums: Vec&#x3C;i32> = vec![];
nums.push(1);
nums.push(2);
nums.push(3);

let pop = nums.pop(); // returns Option&#x3C;T>: None or Some(T)
println!("{:?}", pop);
let number = pop.unwrap();
println!("{}", number);

let two = nums[1]; // copy
// &#x26;nums[1], creates a reference if copy is not available 
// (here we get a copy since i32 is a primitive type)
println!("{}", two);

let one = nums.first(); // return an Option&#x3C;T> 
                        // so None if nums is empty, else Some&#x3C;T>
println!("{:?}", one);

// .last
// .first_mut and .last_mut will borrow mutable references

println!("{}", nums.len()); // return a value of length
println!("{}", nums.is_empty()); // bool

nums.insert(0, 10);
nums.insert(3, 12);
nums.insert(2, 25);

nums.remove(3);

nums.sort();
println!("{:?}", nums);

nums.reverse();
println!("{:?}", nums);

nums.shuffle(&#x26;mut thread_rng());
println!("{:?}", nums);
</code></pre>
<h2>Iterators</h2>
<p>Vec is an example of a standard object that implements the Iterator Trait.</p>
<p>Example 1:</p>
<pre><code class="language-rust">let vec2 = vec![1, 2, 3];
let mut iter = (&#x26;vec2).into_iter();
while let Some(v) = iter.next() {
    println!("{}", v);
}
</code></pre>
<p>Example 2:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Item {
    name: String,
}

fn check_inventory(items: Vec&#x3C;Item>, product: String) -> Vec&#x3C;Item> {
    items.into_iter().filter(|i| i.name == product).collect()
}

fn main() {
    let mut vec: Vec&#x3C;Item> = Vec::new();
    vec.push(Item { name: String::from("coat") });
    vec.push(Item { name: String::from("shirt") });
    vec.push(Item { name: String::from("shorts") });
    vec.push(Item { name: String::from("shoes") });

    let checked = check_inventory(vec, String::from("shirt"));
    println!("{:?}", checked);
}
</code></pre>
<p>Example 3:</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Range {
    start: u32,
    end: u32,
}

impl Iterator for Range {
    type Item = u32;
    fn next(&#x26;mut self) -> Option&#x3C;Self::Item> {
        if self.start >= self.end {
            return None;
        }
        let result = Some(self.start);
        self.start += 1;
        result
    }
}

fn main() {
    let mut range = Range {start: 0, end: 10};
    // for r in range {
    //     println!("{}", r);
    // }

    let vec: Vec&#x3C;u32> = range.filter(|x| x % 2 == 0).collect();
    println!("{:?}",vec);
}
</code></pre>
<h2>Slices</h2>
<pre><code class="language-rust">let v: Vec&#x3C;i32> = (0..5).collect();
println!("{:?}", v);

let sv: &#x26;[i32] = &#x26;v[2..4];
println!("{:?}", sv);
</code></pre>
<p>A slice is a fat pointer i.e. a non owning reference to a <strong>range</strong> of consecutive values.</p>
<h2>Hashmaps</h2>
<pre><code class="language-rust">let mut h: HashMap&#x3C;u8, bool> = HashMap::new();
h.insert(5, true);
h.insert(6, false);
let have_five = h.remove(&#x26;5).unwrap();
</code></pre>
<p>Hashmap API examples:</p>
<pre><code class="language-rust">let mut hm = HashMap::new();
hm.insert(1, 1);
hm.insert(5, 2);
hm.insert(30, 3);
let old = hm.insert(30, 4);
println!("{:?}", hm);
println!("{:?}", old);

println!("{:?}", hm.contains_key(&#x26;8));
println!("{:?}", hm.get(&#x26;5));

let one = hm.remove(&#x26;1);
println!("{:?}", one);

let removed = hm.remove_entry(&#x26;5);
println!("{:?}", removed);

hm.clear();
println!("{}", hm.is_empty());
</code></pre>
<p>Other collections: VecDeque, LinkedList, HashSet, BinaryHeap, BTreeMap, BTreeSet</p>
<h2>HashSets</h2>
<pre><code class="language-rust">let mut hs = HashSet::new();
hs.insert(1);
hs.insert(2);
hs.insert(3);
hs.insert(4);
hs.remove(&#x26;2);
for x in hs.iter() {
    println!("inter: {}", x);
}

let mut hs2 = HashSet::new();
hs2.insert(1);
hs2.insert(3);
hs2.insert(5);
hs2.insert(7);
for x in hs.intersection(&#x26;hs2) {
    println!("intersection: {}", x);
}

let intersection = &#x26;hs &#x26; &#x26;hs2;
for x in intersection {
    println!("short hand way: {}", x);
}

let union = &#x26;hs | &#x26;hs2;
for x in union {
    println!("union: {}", x);
}
</code></pre>
<h2>Enums</h2>
<pre><code class="language-rust">enum Color {
    Red,
    Green,
    Blue,
}
let color = Color::Red;
</code></pre>
<pre><code class="language-rust">enum DispenserItem {
    Empty,
    Ammo(u8),
    Things(String, i32),
    Place {x: i32, y: i32},
}

use DispenserItem::*;
let item1 = Ammo(69);
let item2 = Things("hat".to_string(), 7);
</code></pre>
<pre><code class="language-rust">enum Pet {dog, cat, fish}

impl Pet {
    fn what_am_i(self) -> &#x26;'static str {
        match self {
            Pet::dog => "I am a dog",
            Pet::cat => "I am a cat",
            Pet::fish => "I am a fish",
        }
    }
}
</code></pre>
<h3>The rust predefined Option enum</h3>
<pre><code class="language-rust">enum Option&#x3C;T> {
    Some(T),
    None,
}

let mut x: Option&#x3C;i32> =  None;
x = Some(5);
x.is_some(); // true
x.is_none(); false
for i in x {
    println!("{}", i); // prints 5
}
</code></pre>
<p>The match expression handles the case when we can have Some<T> or Node:</p>
<pre><code class="language-rust">enum Pet {dog, cat, fish}

fn main () {
    let dog = Pet::dog;
    println!("{}", dog.what_am_i());

    let some_number = Some(5);
    let some_string = Some("a string");
    let nothing: Option&#x3C;i32> = None;

    let x: i32 = 5;
    let y: Option&#x3C;i32> = Some(5);

    let sum = x + y;

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{:?}", six);

    let noneUnw = None.unwrap_or(7);
    println!("unw: {:?}", noneUnw);

    what_pet("dog");
    what_pet("cat");
    what_pet("cow");
}

fn plus_one(x: Option&#x3C;i32>) -> Option&#x3C;i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

fn plus_one_unw(x: Option&#x3C;i32>) -> i32 {
    match x {
        None => 0,
        Some(i) => i + 1,
    }
}

fn what_pet(input: &#x26;str) {
    match input {
        "dog" => println!("I have a dog!"),
        "fish" => println!("I have a fish!"),
        "cat" => println!("I have a cat!"),
        _ => println!("I have no clue what pet I have"),
    }
}
</code></pre>
<h3>The rust predefined Result enum</h3>
<pre><code class="language-rust">enum Result&#x3C;T, E> {
    Ok(T),
    Err(E),
}
</code></pre>
<p>Example with Result:</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let res = File::open("foo");
    let f = res.unwrap();
}

fn main() {
    let res = File::open("foo");
    let f = res.expect("error message");
}

fn main() {
    let res = File::open("foo");
    let f = res.is_ok() {
        let f = res.unwrap();
    }
}

fn main() {
    let res = File::open("foo");
    match res {
        Ok(f) => { /* do stuff */ },
        Err(e) => { /* do stuff */ },
    }
}
</code></pre>
<h3>Ownership, references  &#x26; borrowing</h3>
<p>There are 3 rules to ownership:</p>
<ol>
<li>Each value has an owner</li>
<li>There is only one owner of a value</li>
<li>Value gets dropped if its owner goes out of scope</li>
</ol>
<pre><code class="language-rust">x: &#x26;mut i32
*x // a mutable i32
</code></pre>
<pre><code class="language-rust">x: &#x26;i32
*x: // an immutable i32
</code></pre>
<p>At any time, it is possible to have one mutable reference
or any number of immutable references to a given value.</p>
<p>A borrowed variable passed to a function can be dereferenced in two ways.
The first way is automated deferencing:</p>
<pre><code class="language-rust">fn do_stuff(s: &#x26;mut String) {
    s.insert_str(0, "Hi, ");
}
</code></pre>
<p>And the second way is manual:</p>
<pre><code class="language-rust">fn do_stuff(s: &#x26;mut String) {
    *s = String::from("Replacement")
}
</code></pre>
<h2>Raw Pointers</h2>
<p><a href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/">Programming Rust, 2nd Ed</a>:</p>
<p><em>Rust also has the raw pointer types *mut T and *const T. Raw
pointers really are just like pointers in C++. Using a raw
pointer is unsafe, because Rust makes no eï¬€ort to track what
it points to. For example, raw pointers may be null, or they
may point to memory that has been freed or that now
contains a value of a diï¬€erent type.</em> </p>
<p><em>All the classic pointer
mistakes of C++ are oï¬€ered for your enjoyment.
However, you may only dereference raw pointers within an
unsafe block. An unsafe block is Rustâ€™s opt-in mechanism for
advanced language features whose safety is up to you.</em></p>
<h2>Smart Pointers</h2>
<p>Box is a smart pointer that allows to allocate data on the heap
in a straighforward way:</p>
<pre><code class="language-rust">let t = (12, "eggs"); // created on the stack
let b = Box::new(t); // created on the heap, but b was stored on the stack
println!("{:?}", b);

let x = 5;
let y = &#x26;x;
assert_eq!(5, x);
assert_eq!(5, *y);

let x = 5;
let y = Box::new(x);
assert_eq!(5, x);
assert_eq!(5, *y);

println!("{:?}", y);
</code></pre>
<p>Rc is a reference counter that handles and count multiple references to a value.</p>
<pre><code class="language-rust">let s1 = Rc::new(String::from("Pointer"));
let s2 = s1.clone();
let s3 = s2.clone();
println!("{}, {},{}", s1.contains("Point"), s2, s3.contains("er"));
</code></pre>
<p>RefCell allows to mutate data hold in an object whose reference is immutable.</p>
<pre><code class="language-rust">use std::rc::Rc;
use std::cell::RefCell;

struct Flagger {
    is_true: RefCell&#x3C;bool>,
}

let flag= Flagger { is_true: Rc::new(RefCell::new(true)) };
// borrow returns Ref&#x3C;T>
// borrow_mut return RefMut&#x3C;T>

let reference = Rc::new(flag.is_true.clone());
println!("{:?}", reference);

let mut mut_ref = reference.borrow_mut();
*mut_ref = false; // dereference first to access inside
println!("{}", mut_ref);
</code></pre>
<h2>Error handling</h2>
<p>Errors split into two categories: </p>
<ul>
<li>recoverable errors which rely on the result type</li>
<li>unrecoverable errors where the panic macro is used. It terminates the current thread.</li>
</ul>
<p>Example on how to catch an error at opening a file:</p>
<pre><code class="language-rust">let file = File::open("error.txt");
let file = match file {
    Ok(file) => file,
    Err(error) => match error.kind() {
        ErrorKind::NotFound => match File::create("error.txt") {
            Ok(file_created) => file_created,
            Err(err) => panic!("Cannot create the file: {:?}", err),
        },
        _ => panic!("It was some other error kind"),
    },
};
</code></pre>
<p>Here is a simple way to panic and get information on error with logs:</p>
<pre><code class="language-rust">let file = File::open("error.txt").expect("Error opening the file!");
</code></pre>
<p>Finally, an error that occurs in a function can be propagated upwards to the calling
context by adding a question mark to the calling statement like here:</p>
<pre><code class="language-rust">fn open_file() -> Result&#x3C;File, Error> {
    let file = File::open("error.txt")?;
    Ok(file)
}
</code></pre>
<h2>Unit test</h2>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_ne!(result, 5);
    }

    #[test]
    #[should_panic]
    fn it_fails(){
        panic!("Test failed!");
    }

    #[test]
    fn call_simple_add(){
        assert!(simple_add());
    }

}

fn simple_add() -> bool {
    if 2+2 == 4 {
        true
    } else {
        false
    }
}
</code></pre>
<h2>Concurrency</h2>
<pre><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(move || {
        println!("Hello from a thread!")
    });

    handle.join().unwrap();
    println!("Hello from main");

}
</code></pre>
<pre><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];
    let mut thread_handles = Vec::new();

    for e in v {
        // Here the move keyword is forcing the closure to take ownership:
        thread_handles.push(thread::spawn(move || println!("{:?}", e)));
    }

    println!("Main thread!");
    
    for handle in thread_handles {
        handle.join().unwrap();
    }
}
</code></pre>
<p>Threads can communicate between each other with channels.
A channel has a transmitter and a receiver. A channel
is considered closed when either the transmitter or the
receiver is dropped.</p>
<pre><code class="language-rust">use std::thread;
use std::sync::mpsc; // multi producer single consumer

fn main() {
    let (transmitter, receiver) = mpsc::channel();
    
    let val = String::from("Transmitting!");
    thread::spawn(move || {
        transmitter.send(val).unwrap();
    });

    let msg = receiver.recv().unwrap();
    println!("{}", msg);
}
</code></pre>
<p>Types that implement Send are safe to pass by value to another thread. They can be moved accross threads. </p>
<p>Types that implement Sync are safe to pass by non mutable reference to another thread. They can be shared accross threads. </p>
<pre><code class="language-rust">use std::thread;
use std::sync::Arc;

fn main() {
    let rc1 = Arc::new(String::from("test"));
    let rc2 = rc1.clone();
    thread::spawn(move || {
        rc2;
    });
}
</code></pre>
<p>Mutexes allow to manage the access of a variable by several thread.</p>
<pre><code class="language-rust">use std::thread;
use std::sync::{Arc, Mutex};

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..8 {
        let counter = Arc::clone(&#x26;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("{}", counter.lock().unwrap());
}
</code></pre>
<h2>Webassembly</h2>
<h3>Setting up of environment</h3>
<pre><code class="language-bash">rustup update
rustc --version
cargo install cargo-generate
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
nvm install 16.15.0
</code></pre>
<h3>Starting a project</h3>
<p>Run the command:</p>
<pre><code class="language-bash">cargo generate --git https://github.com/rustwasm/wasm-pack-template
</code></pre>
<p>and enter a project name, e.g. wasm-game-of-life when prompted.</p>
<pre><code class="language-bash">cd wasm-game-of-life
wasm-pack build
npm init wasm-app www
cd www
npm start
</code></pre></div><p data-reactid="14"><a href="/workshop/kubernetes" data-reactid="15"><!-- react-text: 16 -->Previous: <!-- /react-text --><!-- react-text: 17 -->Kubernetes<!-- /react-text --></a></p><p data-reactid="18"><a href="/workshop/starport" data-reactid="19"><!-- react-text: 20 -->Next: <!-- /react-text --><!-- react-text: 21 -->Starport<!-- /react-text --></a></p></div></div></div></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-fcd3bd8846658287ca1d.js","205117723866763":"component---src-templates-all-tags-js-a109e949baa4beb6ccfa.js","50739212244294":"component---src-templates-tags-js-f9a8a6f4dec9d1a40211.js","107818501498521":"component---src-templates-blog-post-js-46e2ca802238dc3d0766.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","35783957827783":"component---src-pages-index-js-7187fc4f87660bafea99.js","218538773642512":"component---src-pages-page-2-js-075954cd9c4544c7dcd8.js","60335399758886":"path----557518bd178906f8d58a.js","55702396619907":"path---tags-5b2e6920ed6d3e397e5a.js","267032468795651":"path---tags-authorization-server-c4f16b50b87343ca2433.js","197808841186072":"path---tags-docker-a0b73f70f515cef4f60e.js","235219157580732":"path---tags-elastic-search-a44db677099ebaa51649.js","186255355894769":"path---tags-id-provider-99b7e4736f533d1b6249.js","155380214527963":"path---tags-java-6d7ac820bd39ffb26f0c.js","7155552868840":"path---tags-kafka-5b181f9064e1c4c4bb2d.js","215668504039981":"path---tags-keycloak-6274b4d5e8b9d3837248.js","115329724643966":"path---tags-linux-bb179807d6d86c5bf919.js","61381812668330":"path---tags-logstash-f96d99c46a01ea4b4156.js","272667336710838":"path---tags-no-sql-76f857d780cdb7ac6694.js","280633664576":"path---tags-o-auth-2-3b455ec00f55cd263cb7.js","234996467615793":"path---tags-o-auth-2-0-30bdbbfa7eca98601000.js","138551909326203":"path---tags-redis-88e5100e892199560e39.js","102208518545679":"path---tags-spring-5-3c20e2b744abb25fd03d.js","114139218751285":"path---tags-spring-boot-b0459353699c6392a493.js","106714336011881":"path---tags-spring-security-a249fd88b5bab6c4b352.js","142947283791661":"path---tags-traefik-5a0b747d0d462203cc25.js","179502995171155":"path---tags-webpack-05ba3ca630dffc6a81dc.js","106368396173690":"path---tags-aggregations-e13f6b27bca544c2fb48.js","198337810208020":"path---tags-alerting-a0c6c17f1da41bb0b490.js","32765110312016":"path---tags-aws-48e380036cdbdb847f60.js","38511735442254":"path---tags-bash-59f047dce7f28b683250.js","166852655862137":"path---tags-bookmarks-b10d4839e46004fe3cb6.js","51584254800688":"path---tags-bootstrap-9b07e994edf160a713b0.js","171839609179774":"path---tags-build-64747dd3646cfb88eaad.js","86747829675984":"path---tags-cloud-9ca31af7491b9b63aeec.js","217902700822475":"path---tags-container-45cc8453a74a54b21ec2.js","26710918738984":"path---tags-containers-774420a27abb0e55820f.js","216430911942909":"path---tags-continuous-delivery-17a78fbc8dc86bbbf188.js","203397363053915":"path---tags-continuous-integration-dd4d96b62203b1b6ea59.js","209063065961547":"path---tags-css-2e358821b23b526a2c47.js","212986313302902":"path---tags-devops-67b8ad5dd474b4c8d741.js","170529522467988":"path---tags-environment-variables-139c735457f9318ec1c5.js","20342444442079":"path---tags-es-6-8b2164874250731cf3b6.js","220775049060413":"path---tags-find-79f113952696f093a1f2.js","256443400477714":"path---tags-functional-programming-5971554d7ba0dbde69b2.js","224989948613620":"path---tags-git-f9e6889825e6fb668995.js","260759634830010":"path---tags-github-63a77956d95262141d47.js","256382201114421":"path---tags-gitops-0cb1efe3a56d46cd1c1a.js","29981209658063":"path---tags-go-41e3acb164b7283c2242.js","98025234576756":"path---tags-gradle-15d42bdb8852b9dc926b.js","75192766776157":"path---tags-grep-9a9afb2b102d3367606d.js","150929684164141":"path---tags-idioms-2139a16a12e2c150d6e2.js","42351906034629":"path---tags-images-fc522b88075bc7da0874.js","241037553738466":"path---tags-indexing-1b4cb8f5fa46d2dbf3ec.js","67335324583948":"path---tags-javascript-11c1a67cd740d7de6d4f.js","51523148733183":"path---tags-jhipster-dd66d75a2ece64651764.js","237446219422756":"path---tags-kotlin-ed4924a49986415d7b49.js","194287836265899":"path---tags-kubernetes-96c7bf26dad20107daaf.js","281235003142692":"path---tags-kustomize-35838c9c30c5099fe242.js","273041673360919":"path---tags-mapping-efe04f31ba5dc93106a8.js","114196857698578":"path---tags-maven-0a5db9d4d222aa723cdd.js","255270140647221":"path---tags-memoization-0e438c501abb2b37ac20.js","180191951036024":"path---tags-mobile-app-020a9b88a11dcb5f5045.js","128479622566067":"path---tags-mongo-9c468fd3b399a0408002.js","163682887060854":"path---tags-monitoring-85cbd73dbef42cfcea5d.js","142673295708428":"path---tags-networks-99c27d04351670e5fe9a.js","211759861687086":"path---tags-project-reactor-635fcc9ef720b63f082d.js","52082389606136":"path---tags-prometheus-28a162e5c6f4ff1740d6.js","272106575661425":"path---tags-queries-262b26881affd40b952d.js","164326542535565":"path---tags-react-native-045bfbdd64048a3407a5.js","80857547258750":"path---tags-rename-ec7a90788a2401594ee0.js","258905265707556":"path---tags-rust-485fa28134f7b6ca8526.js","27451989507627":"path---tags-searching-bd6023fe7edc6cbbb8d7.js","83322114851053":"path---tags-starport-26d1e096fab303d92586.js","31611659233640":"path---tags-style-83bd2f042ac6cc18344c.js","262272620832655":"path---tags-system-3d14b06f0b686ab642b5.js","276438921840512":"path---tags-telemetry-13b20dfb5c2405c3fed4.js","41936493277345":"path---tags-toolbox-1ae72e7263c7053f095b.js","134828663280566":"path---tags-utils-eeffe69d4e8fdf671290.js","152410062127997":"path---tags-vi-7d7b34bc9d1fadcf1715.js","250728022720538":"path---tags-web-security-89c1a98003359f3bba47.js","264709711041873":"path---es-6-toolbox-10ee50fa7f6ce1dd79e1.js","241575767447496":"path---elk-searching-fbd0dd1a028843bb9683.js","136351407110125":"path---docker-recipes-ca25aa8ae20b6f337896.js","44495949915592":"path---bookmarks-2bce9ccebdf823530ddf.js","27340383070158":"path---elk-mapping-08e2f450ed24c87882c5.js","275926882428397":"path---jhipster-a8af7203729cc81a2549.js","75971844984152":"path---style-2c374d9706a57be52b48.js","186373792209034":"path---oauth-2-in-spring-boot-5b7b28c8274fc9a2be53.js","84860036509320":"path---keycloak-5812db7d4ece62f28781.js","233636700692276":"path---elk-useful-queries-472bc5fdddecd93bdc3b.js","45807363123603":"path---kafka-f91fddca02cee0f19db4.js","73536867654473":"path---oauth-2-39dc24c18c707798cb14.js","270558778719961":"path---react-native-ffbf7c8366fcc5b952d1.js","17255058156401":"path---webpack-385a269f9aff0da5eb9e.js","142119514647577":"path---redis-2796fdbd1ec81fdcad2c.js","86452829880231":"path---traefik-103bc995ab4afc7a7c34.js","164212287735341":"path---mongo-dbd6d250d58391f4e324.js","54858438791056":"path---kubernetes-03f6a4fbbad292e85d2f.js","101400775151803":"path---rust-258af777f2459be8b0ac.js","183459928519066":"path---starport-4cb05a4435cebda51806.js","43486006993984":"path---github-63465e4e6c9a8fe6a766.js","9925493097308":"path---go-51663af40e275a73e848.js","137461176384111":"path---argocd-e0ba0286b15f3d6f06f1.js","116647980945435":"path---idioms-68947c8d1f45e6a1bd1f.js","247459877702488":"path---docker-concepts-ee259336db1d5fce58d4.js","5081115688789":"path---project-reactor-3cf181f0304894ee57c5.js","16183777268280":"path---git-dc3d0e57ebe0f74cb145.js","248432161912651":"path---prometheus-6f546c0eb86e6f102ecd.js","276602839367171":"path---linux-utils-c66d47777f3d8d7a34c1.js","171959534233400":"path---maven-34d2fa6a394706a9965a.js","209356175302241":"path---gradle-b36968765e36895f6466.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-508d85b7f2f4c7a22b6a.js","135728916539164":"path---page-2-a0e39f21c11f6a62c5ab.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-1e3fc81ebbae08575bfd.js"}/*]]>*/</script><script>/*<![CDATA[*/["/workshop/commons-99efdf1a76a6a156fb09.js","/workshop/app-fcd3bd8846658287ca1d.js","/workshop/path---rust-258af777f2459be8b0ac.js","/workshop/component---src-templates-blog-post-js-46e2ca802238dc3d0766.js","/workshop/component---src-layouts-index-js-1e3fc81ebbae08575bfd.js"].forEach(function(s){document.write('<script src="'+s+'" defer></'+'script>')})/*]]>*/</script></body></html>