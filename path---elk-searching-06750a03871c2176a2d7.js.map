{"version":3,"sources":["webpack:///path---elk-searching-06750a03871c2176a2d7.js","webpack:///./.cache/json/elk-searching.json"],"names":["webpackJsonp","391","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","prev","id","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,soKAA22KC,aAAiCC,MAAA,+BAAAC,KAAA,kBAAAC,KAAA,iBAAAC,MAAA,8BAAAC,QAAA,MAA6IC,aAAgBC,MAAQR,KAAA,soKAA22KS,GAAA,yGAAAR,aAA+IE,KAAA,2BAAAC,KAAA,iBAAAF,MAAA,+BAAAI,QAAA,GAAAD,MAAA,gCAAqJK,MAASV,KAAA,ooFAAk8ES,GAAA,yHAAAR,aAA4VE,KAAA,2BAAAC,KAAA,yBAAAF,MAAA,2BAAAI,QAAA,GAAAD,MAAA","file":"path---elk-searching-06750a03871c2176a2d7.js","sourcesContent":["webpackJsonp([241575767447496],{\n\n/***/ 391:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"frontmatter\":{\"title\":\"Searching with Elasticsearch\",\"date\":\"August 29, 2020\",\"path\":\"/elk-searching\",\"tags\":[\"Elastic Search\",\"searching\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"id\":\"/home/nicolas/projects/workshop/src/pages/2020-08-29-ELK-2/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-08-29T22:47:32.235Z\",\"path\":\"/elk-searching\",\"title\":\"Searching with Elasticsearch\",\"excerpt\":\"\",\"tags\":[\"Elastic Search\",\"searching\"]}},\"next\":{\"html\":\"<h3>OAuth 2.0 in Spring Security 5</h3>\\n<p>The legacy <a href=\\\"https://github.com/spring-projects/spring-security-oauth\\\">Spring Security OAuth Project</a> includes support for implementing all of the three roles involved in OAuth: Client, Resource Server and Authorization Server. However, that project is now deprecated and to be maintained only for a limited time\\nuntil not later than may 2022. </p>\\n<p>The new OAuth 2 project (<a href=\\\"https://github.com/spring-projects-experimental/spring-authorization-server\\\">https://github.com/spring-projects-experimental/spring-authorization-server</a>)\\nwhich is part of Spring Security 5 is already available but not fully developed as yet. A\\nclient and a resource server are already available. However,\\nthe <a href=\\\"https://github.com/spring-projects-experimental/spring-authorization-server\\\">authorization server</a> project is not completed as of december 2020. </p>\\n<h3>The two types of clients</h3>\\n<p>Client applications can be split into two categories: </p>\\n<ul>\\n<li>confidential clients where the client secret is kept safe.</li>\\n<li>public clients which cannot keep their client id and client secret safe. It is the case of\\napplications which are browser based like pure front end javascript applications. It is also\\nthe case of some native applications stored in smartphones. It is the case of any application\\nwhose code can be viewed or decompiled.</li>\\n</ul>\\n<h2>The different grant types i.e. ways an application gets an access token</h2>\\n<p>Authorization code and Client credentials are the most common grant types. Implicit flow and Password grant are two other grant types of Oauth 2 which are now deprecated. There are now two additional possible grant types which can be relevant in some types of applications: PKCE Enhanced authorization code and Device code. Note that PKCE stands for Proof Key for Code Exchange.</p>\\n<p>Here are five different types of applications with their relevant grant types:</p>\\n<ul>\\n<li>Server Side Web Apps: <strong>Authorisation Code</strong> ; Password grant (deprecated).</li>\\n<li>Server Side Script with no UI : <strong>Client Credentials</strong></li>\\n<li>Javascript Single Page Application with no back end: <strong>PKCE Enhanced Authorization Code</strong>; Implicit Flow (deprecated) ; Password Grant (deprecated).</li>\\n<li>Mobile native app : <strong>Authorization Code</strong>; <strong>PKCE Enhanced Authorization Code</strong> ; Implicit Flow (deprecated) ; Password Grant (deprecated).</li>\\n<li>Device : <strong>Device Code</strong>.</li>\\n</ul>\\n<p>Finally, Refresh Token is an additional Grant Type where a refresh token is exchanged for an access token.</p>\",\"id\":\"/home/nicolas/projects/workshop/src/pages/2020-11-15-oauth2-in-spring-boot/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-11-15T17:23:14.538Z\",\"path\":\"/oauth2-in-spring-boot\",\"title\":\"Oauth 2.0 in Spring Boot\",\"excerpt\":\"\",\"tags\":[\"web security\",\"OAuth 2.0\",\"Spring Boot\",\"Spring Security\",\"Spring 5\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---elk-searching-06750a03871c2176a2d7.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"frontmatter\":{\"title\":\"Searching with Elasticsearch\",\"date\":\"August 29, 2020\",\"path\":\"/elk-searching\",\"tags\":[\"Elastic Search\",\"searching\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"id\":\"/home/nicolas/projects/workshop/src/pages/2020-08-29-ELK-2/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-08-29T22:47:32.235Z\",\"path\":\"/elk-searching\",\"title\":\"Searching with Elasticsearch\",\"excerpt\":\"\",\"tags\":[\"Elastic Search\",\"searching\"]}},\"next\":{\"html\":\"<h3>OAuth 2.0 in Spring Security 5</h3>\\n<p>The legacy <a href=\\\"https://github.com/spring-projects/spring-security-oauth\\\">Spring Security OAuth Project</a> includes support for implementing all of the three roles involved in OAuth: Client, Resource Server and Authorization Server. However, that project is now deprecated and to be maintained only for a limited time\\nuntil not later than may 2022. </p>\\n<p>The new OAuth 2 project (<a href=\\\"https://github.com/spring-projects-experimental/spring-authorization-server\\\">https://github.com/spring-projects-experimental/spring-authorization-server</a>)\\nwhich is part of Spring Security 5 is already available but not fully developed as yet. A\\nclient and a resource server are already available. However,\\nthe <a href=\\\"https://github.com/spring-projects-experimental/spring-authorization-server\\\">authorization server</a> project is not completed as of december 2020. </p>\\n<h3>The two types of clients</h3>\\n<p>Client applications can be split into two categories: </p>\\n<ul>\\n<li>confidential clients where the client secret is kept safe.</li>\\n<li>public clients which cannot keep their client id and client secret safe. It is the case of\\napplications which are browser based like pure front end javascript applications. It is also\\nthe case of some native applications stored in smartphones. It is the case of any application\\nwhose code can be viewed or decompiled.</li>\\n</ul>\\n<h2>The different grant types i.e. ways an application gets an access token</h2>\\n<p>Authorization code and Client credentials are the most common grant types. Implicit flow and Password grant are two other grant types of Oauth 2 which are now deprecated. There are now two additional possible grant types which can be relevant in some types of applications: PKCE Enhanced authorization code and Device code. Note that PKCE stands for Proof Key for Code Exchange.</p>\\n<p>Here are five different types of applications with their relevant grant types:</p>\\n<ul>\\n<li>Server Side Web Apps: <strong>Authorisation Code</strong> ; Password grant (deprecated).</li>\\n<li>Server Side Script with no UI : <strong>Client Credentials</strong></li>\\n<li>Javascript Single Page Application with no back end: <strong>PKCE Enhanced Authorization Code</strong>; Implicit Flow (deprecated) ; Password Grant (deprecated).</li>\\n<li>Mobile native app : <strong>Authorization Code</strong>; <strong>PKCE Enhanced Authorization Code</strong> ; Implicit Flow (deprecated) ; Password Grant (deprecated).</li>\\n<li>Device : <strong>Device Code</strong>.</li>\\n</ul>\\n<p>Finally, Refresh Token is an additional Grant Type where a refresh token is exchanged for an access token.</p>\",\"id\":\"/home/nicolas/projects/workshop/src/pages/2020-11-15-oauth2-in-spring-boot/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-11-15T17:23:14.538Z\",\"path\":\"/oauth2-in-spring-boot\",\"title\":\"Oauth 2.0 in Spring Boot\",\"excerpt\":\"\",\"tags\":[\"web security\",\"OAuth 2.0\",\"Spring Boot\",\"Spring Security\",\"Spring 5\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/elk-searching.json\n// module id = 391\n// module chunks = 241575767447496"],"sourceRoot":""}