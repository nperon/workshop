{"version":3,"sources":["webpack:///path---rust-cb055b0c7fbdb012cb66.js","webpack:///./.cache/json/rust.json"],"names":["webpackJsonp","470","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","prev","id","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,2tuBAAg5tBC,aAA8pBC,MAAA,OAAAC,KAAA,oBAAAC,KAAA,QAAAC,MAAA,QAAAC,QAAA,MAAwFC,aAAgBC,MAAQR,KAAA;AAA0moBS,GAAA,wHAAAR,aAA6/BE,KAAA,2BAAAC,KAAA,MAAAF,MAAA,KAAAI,QAAA,KAAAD,MAAA,QAA0FK,MAASV,KAAA,isQAAooOS,GAAA,4HAAAR,aAAswCE,KAAA,2BAAAC,KAAA,UAAAF,MAAA,UAAAI,QAAA,GAAAD,MAAA","file":"path---rust-cb055b0c7fbdb012cb66.js","sourcesContent":["webpackJsonp([101400775151803],{\n\n/***/ 470:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Cargo commands</h2>\\n<p>Command to create a project:</p>\\n<pre><code class=\\\"language-bash\\\">cargo new hello\\n</code></pre>\\n<p>You can compile and run the project now with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo run\\n</code></pre>\\n<p>This builds the project in a directory called <code>target/debug</code>.\\nTo build the project in the <code>target/release</code> directory intended for prod, just run:</p>\\n<pre><code class=\\\"language-bash\\\">cargo run --release\\n</code></pre>\\n<p>A good tip to improve the code with idiomatic rust coding hints/warnings is to run:</p>\\n<pre><code class=\\\"language-bash\\\">cargo clippy\\n</code></pre>\\n<p>Here is a command to view the standard library in the default browser:</p>\\n<pre><code class=\\\"language-bash\\\">rustup doc --std\\n</code></pre>\\n<h3>Coding modules</h3>\\n<p>Crates are about code sharing between projects while modules are about\\ncode sharing within a project. </p>\\n<p>This can take place in a package library. This can be created with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo new todo --lib\\n</code></pre>\\n<p>Cargo modules is a useful tool to manage modules. It can be installed with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo install cargo-modules\\n</code></pre>\\n<p>Then, project's modules tree can be displayed with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo modules generate tree\\n</code></pre>\\n<p>The displayed tree can be refined with options:</p>\\n<pre><code class=\\\"language-bash\\\">cargo modules generate tree --with-types\\n</code></pre>\\n<h2>Strings</h2>\\n<p>String slices refered to as <code>str</code>\\nare almost always handled in the shape of borrowed string slices <code>&#x26;str</code>.\\nSee also the Rust documentation on <a href=\\\"https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\\">references and borrowing</a>.</p>\\n<p>A string literal stated\\n<code>let msg = \\\"Hello ðŸŒŽ\\\";</code>\\nis a borrowed string slice.</p>\\n<p>The other string type is String.\\nData in a borrowed string slice cannot be modified\\nwhile data in a String can be modified.</p>\\n<p>A String can be obtained by applying the to_string() method on a\\nborrowed string slice:</p>\\n<pre><code>let msg = \\\"abðŸŽ‰\\\".to_string();\\n</code></pre>\\n<p>or else by passing the borrowed string slice to String::from:</p>\\n<pre><code>let msg = String::from(\\\"abðŸŽ‰\\\");\\n</code></pre>\\n<p>Internally, a borrowed string slice is made up of a pointer to some byte and\\na length. The length is the number of unicode characters in the string.</p>\\n<p>Bytes can be extracted from a borrowed string slice with the bytes() method: <code>word.bytes();</code></p>\\n<p>An iterator on unicode scalars can be built with <code>word.chars();</code></p>\\n<p>Additionally, an iterator on graphemes can be retrieved using a package called unicode-segmentation with:</p>\\n<p><code>graphemes(my_string, true)</code></p>\\n<p>A given item in the graphemes can then be accessed with by appending a statement like<code>.nth(3)</code></p>\\n<p>All of the helper methods to manipulate String objects are documented\\n<a href=\\\"https://doc.rust-lang.org/std/string/struct.String.html#method.bytes\\\">here</a>.</p>\\n<p>A String can be converted into a &#x26;str with the <code>.as_str()</code> method.\\nIt follows that string slices can manipulated in the shape of String objects\\nand the latter can be converted back into string slices with <code>as_str()</code>.\\nFor instance two <code>&#x26;str</code> can be concatenated into a string c with:</p>\\n<pre><code class=\\\"language-bash\\\">let a = \\\"Hello\\\";\\nlet b = \\\" World\\\";\\nlet c = format!(\\\"{}{}\\\", a, b);\\n</code></pre>\\n<h2>String literals</h2>\\n<pre><code class=\\\"language-rust\\\">let rust = \\\"\\\\x52\\\\x75\\\\x73\\\\x74\\\";\\nprintln!(\\\"{}\\\", rust);\\n</code></pre>\\n<h2>Struct with impl</h2>\\n<pre><code class=\\\"language-rust\\\">struct Square {\\n    width: u32,\\n    height: u32,\\n}\\n\\nimpl Square {\\n    fn area(&#x26;self) -> u32 {\\n        self.width * self.height\\n    }\\n\\n    fn whats_my_width(&#x26;self) -> u32 {\\n        self.width\\n    }\\n\\n    fn change_width(&#x26;mut self, new_width: u32){\\n        self.width = new_width;\\n    }\\n}\\n</code></pre>\\n<h2>Struct with Trait</h2>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct RedFox {\\n    enemy: bool,\\n    life: u32,\\n}\\n\\ntrait Noisy {\\n    fn get_noise(&#x26;self) -> &#x26;str;\\n}\\n\\nimpl Noisy for RedFox {\\n    fn get_noise(&#x26;self) -> &#x26;str { \\\"Meow?\\\" }\\n}\\n\\nfn print_noise&#x3C;T: Noisy>(item: T) {\\n    println!(\\\"\\\", item.get_noise());\\n}\\n\\nimpl Noisy for u8 {\\n    fn get_noise(&#x26;self) -> &#x26;str { \\\"BYTE!\\\" }\\n}\\n\\nfn main() {\\n    print_noise(5_u8); // prints \\\"BYTE!\\\"\\n}\\n</code></pre>\\n<p>There are two other types of Struct. One is the tuple like Struct:</p>\\n<pre><code class=\\\"language-rust\\\">struct Coordinates(i32, i32, i32);\\n</code></pre>\\n<p>The other is the unit like Struct which is useful when combined with Traits:</p>\\n<pre><code class=\\\"language-rust\\\">struct UnitStruct;\\n</code></pre>\\n<h2>Utility Traits</h2>\\n<ul>\\n<li>The Drop Trait:</li>\\n</ul>\\n<pre><code class=\\\"language-rust\\\">struct Course {\\n    headline: String,\\n    author: String,\\n}\\n\\nimpl Drop for Course {\\n    fn drop(&#x26;mut self) {\\n        println!(\\\"Dropping: {}\\\", self.author);\\n    }\\n}\\n\\nfn main() {\\n    let course1 = Course{ headline: String::from(\\\"Headline!\\\"), author: String::from(\\\"Tyler\\\"), };\\n\\n    drop(course1);\\n}\\n</code></pre>\\n<ul>\\n<li>The Clone Trait which is for types that can make copies of themselves :</li>\\n</ul>\\n<pre><code class=\\\"language-rust\\\">trait Clone: Sized {\\n    fn clone(&#x26;self) -> Self;\\n    fn clone_from(&#x26;mut self, source: &#x26;Self) {\\n        *self = source.clone()\\n    }\\n}\\n</code></pre>\\n<ul>\\n<li>\\n<p>Copy is a shallow Clone</p>\\n</li>\\n<li>\\n<p>From and Into, plus: TryFrom and TryInto</p>\\n</li>\\n</ul>\\n<p><code>fn into(self) -> T</code>: take self and returns a value of type T.</p>\\n<p><code>fn from(T) -> Self</code>: take a value of type T and returns self.</p>\\n<ul>\\n<li>Arithmetics: the Add Trait</li>\\n</ul>\\n<pre><code class=\\\"language-bash\\\">use std::ops::Add;\\n\\n#[derive(Debug)]\\nstruct Point&#x3C;T> {\\n    x: T,\\n    y: T\\n}\\n\\nfn main() {\\n    let coord = Point{ x: 5.0, y: 5.0 };\\n    let coord2 = Point{ x: 1.0, y: 2.0 };\\n    let sum = coord + coord2;\\n    println!(\\\"{:?}\\\", sum);\\n}\\n\\nimpl&#x3C;T> Add for Point&#x3C;T>\\n    where\\n    T: Add&#x3C;Output = T> {\\n        type Output = Self;        \\n        fn add(self, rhs: Self) -> Self {\\n            Point {\\n                x: self.x + rhs.x,\\n                y: self.y + rhs.y,\\n            }\\n        }\\n    }\\n</code></pre>\\n<ul>\\n<li>\\n<p>Fn is a family of closures and functions that you can call multiple times without restrictions. It borrows values from the environment immutably. It includes all fn functions.</p>\\n</li>\\n<li>\\n<p>FnMut is a family of closures and functions that you can call multiple times if the closure itself is declared mut. It immutably borrows values.</p>\\n</li>\\n<li>\\n<p>FnOnce is a family of closures that can be called once if the caller owns the closure. The closure cannot take ownership of the same variables more than once.</p>\\n</li>\\n</ul>\\n<p>Therefore, every Fn meets the requirements for FnMut and every FnMut meets the requirements for FnOnce. It means that Fn is the most exclusive and the most powerful in this set of three Traits.</p>\\n<p>Examples: </p>\\n<ul>\\n<li>\\n<p>|| drop(v) FnOnce  ---> FnOnce</p>\\n</li>\\n<li>\\n<p>|args| v.contains(arg) ---> Fn</p>\\n</li>\\n<li>\\n<p>|args| v.push(arg)  ---> FnMut</p>\\n</li>\\n<li>\\n<p>Iterator</p>\\n</li>\\n</ul>\\n<h2>Lifetimes</h2>\\n<p>Every reference has a Lifetime. Most of the time, Lifetimes are implicit and inferred.</p>\\n<pre><code class=\\\"language-rust\\\">fn longest&#x3C;'a>(x: &#x26;'a str, y: &#x26;'a str) -> &#x26;'a str {\\n    if x.len() > y.len() {\\n        x\\n    } else {\\n        y\\n    }\\n}\\n</code></pre>\\n<p>Syntax for lifetime in a struct is as follows:</p>\\n<pre><code class=\\\"language-rust\\\">struct MyString&#x3C;'a> {\\n    text: &#x26;'a str\\n}\\n</code></pre>\\n<p>Here is an example of a variable defined with a static lifetime:</p>\\n<pre><code class=\\\"language-rust\\\">let s: &#x26;'static str = \\\"I have static lifetime\\\";\\n</code></pre>\\n<h2>Vectors</h2>\\n<pre><code class=\\\"language-rust\\\">let mut v: Vec&#x3C;i32> = Vec::new();\\nv.push(2);\\nv.push(4);\\nv.push(6);\\nlet x = v.pop();    // x is 6\\nprintln(\\\"{}\\\", v[1]);// prints \\\"4\\\"\\nlet mut u = vec![2, 4, 6];\\n</code></pre>\\n<p>Other ways to instanciate vectors: </p>\\n<pre><code class=\\\"language-rust\\\">let vect= Vec::&#x3C;i32>::with_capacity(2);\\nprintln!(\\\"{}\\\", vect.capacity());\\n\\nlet v: Vec&#x3C;i32> = (0..5).collect();\\nprintln!(\\\"{:?}\\\", v);\\n</code></pre>\\n<p>Vector API examples:</p>\\n<pre><code class=\\\"language-rust\\\">let mut nums: Vec&#x3C;i32> = vec![];\\nnums.push(1);\\nnums.push(2);\\nnums.push(3);\\n\\nlet pop = nums.pop(); // returns Option&#x3C;T>: None or Some(T)\\nprintln!(\\\"{:?}\\\", pop);\\nlet number = pop.unwrap();\\nprintln!(\\\"{}\\\", number);\\n\\nlet two = nums[1]; // copy\\n// &#x26;nums[1], creates a reference if copy is not available \\n// (here we get a copy since i32 is a primitive type)\\nprintln!(\\\"{}\\\", two);\\n\\nlet one = nums.first(); // return an Option&#x3C;T> \\n                        // so None if nums is empty, else Some&#x3C;T>\\nprintln!(\\\"{:?}\\\", one);\\n\\n// .last\\n// .first_mut and .last_mut will borrow mutable references\\n\\nprintln!(\\\"{}\\\", nums.len()); // return a value of length\\nprintln!(\\\"{}\\\", nums.is_empty()); // bool\\n\\nnums.insert(0, 10);\\nnums.insert(3, 12);\\nnums.insert(2, 25);\\n\\nnums.remove(3);\\n\\nnums.sort();\\nprintln!(\\\"{:?}\\\", nums);\\n\\nnums.reverse();\\nprintln!(\\\"{:?}\\\", nums);\\n\\nnums.shuffle(&#x26;mut thread_rng());\\nprintln!(\\\"{:?}\\\", nums);\\n</code></pre>\\n<h2>Iterators</h2>\\n<p>Vec is an example of a standard object that implements the Iterator Trait.</p>\\n<p>Example 1:</p>\\n<pre><code class=\\\"language-rust\\\">let vec2 = vec![1, 2, 3];\\nlet mut iter = (&#x26;vec2).into_iter();\\nwhile let Some(v) = iter.next() {\\n    println!(\\\"{}\\\", v);\\n}\\n</code></pre>\\n<p>Example 2:</p>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct Item {\\n    name: String,\\n}\\n\\nfn check_inventory(items: Vec&#x3C;Item>, product: String) -> Vec&#x3C;Item> {\\n    items.into_iter().filter(|i| i.name == product).collect()\\n}\\n\\nfn main() {\\n    let mut vec: Vec&#x3C;Item> = Vec::new();\\n    vec.push(Item { name: String::from(\\\"coat\\\") });\\n    vec.push(Item { name: String::from(\\\"shirt\\\") });\\n    vec.push(Item { name: String::from(\\\"shorts\\\") });\\n    vec.push(Item { name: String::from(\\\"shoes\\\") });\\n\\n    let checked = check_inventory(vec, String::from(\\\"shirt\\\"));\\n    println!(\\\"{:?}\\\", checked);\\n}\\n</code></pre>\\n<p>Example 3:</p>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct Range {\\n    start: u32,\\n    end: u32,\\n}\\n\\nimpl Iterator for Range {\\n    type Item = u32;\\n    fn next(&#x26;mut self) -> Option&#x3C;Self::Item> {\\n        if self.start >= self.end {\\n            return None;\\n        }\\n        let result = Some(self.start);\\n        self.start += 1;\\n        result\\n    }\\n}\\n\\nfn main() {\\n    let mut range = Range {start: 0, end: 10};\\n    // for r in range {\\n    //     println!(\\\"{}\\\", r);\\n    // }\\n\\n    let vec: Vec&#x3C;u32> = range.filter(|x| x % 2 == 0).collect();\\n    println!(\\\"{:?}\\\",vec);\\n}\\n</code></pre>\\n<h2>Slices</h2>\\n<pre><code class=\\\"language-rust\\\">let v: Vec&#x3C;i32> = (0..5).collect();\\nprintln!(\\\"{:?}\\\", v);\\n\\nlet sv: &#x26;[i32] = &#x26;v[2..4];\\nprintln!(\\\"{:?}\\\", sv);\\n</code></pre>\\n<p>A slice is a fat pointer i.e. a non owning reference to a <strong>range</strong> of consecutive values.</p>\\n<h2>Hashmaps</h2>\\n<pre><code class=\\\"language-rust\\\">let mut h: HashMap&#x3C;u8, bool> = HashMap::new();\\nh.insert(5, true);\\nh.insert(6, false);\\nlet have_five = h.remove(&#x26;5).unwrap();\\n</code></pre>\\n<p>Hashmap API examples:</p>\\n<pre><code class=\\\"language-rust\\\">let mut hm = HashMap::new();\\nhm.insert(1, 1);\\nhm.insert(5, 2);\\nhm.insert(30, 3);\\nlet old = hm.insert(30, 4);\\nprintln!(\\\"{:?}\\\", hm);\\nprintln!(\\\"{:?}\\\", old);\\n\\nprintln!(\\\"{:?}\\\", hm.contains_key(&#x26;8));\\nprintln!(\\\"{:?}\\\", hm.get(&#x26;5));\\n\\nlet one = hm.remove(&#x26;1);\\nprintln!(\\\"{:?}\\\", one);\\n\\nlet removed = hm.remove_entry(&#x26;5);\\nprintln!(\\\"{:?}\\\", removed);\\n\\nhm.clear();\\nprintln!(\\\"{}\\\", hm.is_empty());\\n</code></pre>\\n<p>Other collections: VecDeque, LinkedList, HashSet, BinaryHeap, BTreeMap, BTreeSet</p>\\n<h2>HashSets</h2>\\n<pre><code class=\\\"language-rust\\\">let mut hs = HashSet::new();\\nhs.insert(1);\\nhs.insert(2);\\nhs.insert(3);\\nhs.insert(4);\\nhs.remove(&#x26;2);\\nfor x in hs.iter() {\\n    println!(\\\"inter: {}\\\", x);\\n}\\n\\nlet mut hs2 = HashSet::new();\\nhs2.insert(1);\\nhs2.insert(3);\\nhs2.insert(5);\\nhs2.insert(7);\\nfor x in hs.intersection(&#x26;hs2) {\\n    println!(\\\"intersection: {}\\\", x);\\n}\\n\\nlet intersection = &#x26;hs &#x26; &#x26;hs2;\\nfor x in intersection {\\n    println!(\\\"short hand way: {}\\\", x);\\n}\\n\\nlet union = &#x26;hs | &#x26;hs2;\\nfor x in union {\\n    println!(\\\"union: {}\\\", x);\\n}\\n</code></pre>\\n<h2>Enums</h2>\\n<pre><code class=\\\"language-rust\\\">enum Color {\\n    Red,\\n    Green,\\n    Blue,\\n}\\nlet color = Color::Red;\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">enum DispenserItem {\\n    Empty,\\n    Ammo(u8),\\n    Things(String, i32),\\n    Place {x: i32, y: i32},\\n}\\n\\nuse DispenserItem::*;\\nlet item1 = Ammo(69);\\nlet item2 = Things(\\\"hat\\\".to_string(), 7);\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">enum Pet {dog, cat, fish}\\n\\nimpl Pet {\\n    fn what_am_i(self) -> &#x26;'static str {\\n        match self {\\n            Pet::dog => \\\"I am a dog\\\",\\n            Pet::cat => \\\"I am a cat\\\",\\n            Pet::fish => \\\"I am a fish\\\",\\n        }\\n    }\\n}\\n</code></pre>\\n<h3>The rust predefined Option enum</h3>\\n<pre><code class=\\\"language-rust\\\">enum Option&#x3C;T> {\\n    Some(T),\\n    None,\\n}\\n\\nlet mut x: Option&#x3C;i32> =  None;\\nx = Some(5);\\nx.is_some(); // true\\nx.is_none(); false\\nfor i in x {\\n    println!(\\\"{}\\\", i); // prints 5\\n}\\n</code></pre>\\n<p>The match expression handles the case when we can have Some<T> or Node:</p>\\n<pre><code class=\\\"language-rust\\\">enum Pet {dog, cat, fish}\\n\\nfn main () {\\n    let dog = Pet::dog;\\n    println!(\\\"{}\\\", dog.what_am_i());\\n\\n    let some_number = Some(5);\\n    let some_string = Some(\\\"a string\\\");\\n    let nothing: Option&#x3C;i32> = None;\\n\\n    let x: i32 = 5;\\n    let y: Option&#x3C;i32> = Some(5);\\n\\n    let sum = x + y;\\n\\n    let five = Some(5);\\n    let six = plus_one(five);\\n    let none = plus_one(None);\\n\\n    println!(\\\"{:?}\\\", six);\\n\\n    let noneUnw = None.unwrap_or(7);\\n    println!(\\\"unw: {:?}\\\", noneUnw);\\n\\n    what_pet(\\\"dog\\\");\\n    what_pet(\\\"cat\\\");\\n    what_pet(\\\"cow\\\");\\n}\\n\\nfn plus_one(x: Option&#x3C;i32>) -> Option&#x3C;i32> {\\n    match x {\\n        None => None,\\n        Some(i) => Some(i + 1),\\n    }\\n}\\n\\nfn plus_one_unw(x: Option&#x3C;i32>) -> i32 {\\n    match x {\\n        None => 0,\\n        Some(i) => i + 1,\\n    }\\n}\\n\\nfn what_pet(input: &#x26;str) {\\n    match input {\\n        \\\"dog\\\" => println!(\\\"I have a dog!\\\"),\\n        \\\"fish\\\" => println!(\\\"I have a fish!\\\"),\\n        \\\"cat\\\" => println!(\\\"I have a cat!\\\"),\\n        _ => println!(\\\"I have no clue what pet I have\\\"),\\n    }\\n}\\n</code></pre>\\n<h3>The rust predefined Result enum</h3>\\n<pre><code class=\\\"language-rust\\\">enum Result&#x3C;T, E> {\\n    Ok(T),\\n    Err(E),\\n}\\n</code></pre>\\n<p>Example with Result:</p>\\n<pre><code class=\\\"language-rust\\\">use std::fs::File;\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.unwrap();\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.expect(\\\"error message\\\");\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.is_ok() {\\n        let f = res.unwrap();\\n    }\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    match res {\\n        Ok(f) => { /* do stuff */ },\\n        Err(e) => { /* do stuff */ },\\n    }\\n}\\n</code></pre>\\n<h3>Ownership, references  &#x26; borrowing</h3>\\n<p>There are 3 rules to ownership:</p>\\n<ol>\\n<li>Each value has an owner</li>\\n<li>There is only one owner of a value</li>\\n<li>Value gets dropped if its owner goes out of scope</li>\\n</ol>\\n<pre><code class=\\\"language-rust\\\">x: &#x26;mut i32\\n*x // a mutable i32\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">x: &#x26;i32\\n*x: // an immutable i32\\n</code></pre>\\n<p>At any time, it is possible to have one mutable reference\\nor any number of immutable references to a given value.</p>\\n<p>A borrowed variable passed to a function can be dereferenced in two ways.\\nThe first way is automated deferencing:</p>\\n<pre><code class=\\\"language-rust\\\">fn do_stuff(s: &#x26;mut String) {\\n    s.insert_str(0, \\\"Hi, \\\");\\n}\\n</code></pre>\\n<p>And the second way is manual:</p>\\n<pre><code class=\\\"language-rust\\\">fn do_stuff(s: &#x26;mut String) {\\n    *s = String::from(\\\"Replacement\\\")\\n}\\n</code></pre>\\n<h2>Raw Pointers</h2>\\n<p><a href=\\\"https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/\\\">Programming Rust, 2nd Ed</a>:</p>\\n<p><em>Rust also has the raw pointer types *mut T and *const T. Raw\\npointers really are just like pointers in C++. Using a raw\\npointer is unsafe, because Rust makes no eï¬€ort to track what\\nit points to. For example, raw pointers may be null, or they\\nmay point to memory that has been freed or that now\\ncontains a value of a diï¬€erent type.</em> </p>\\n<p><em>All the classic pointer\\nmistakes of C++ are oï¬€ered for your enjoyment.\\nHowever, you may only dereference raw pointers within an\\nunsafe block. An unsafe block is Rustâ€™s opt-in mechanism for\\nadvanced language features whose safety is up to you.</em></p>\\n<h2>Smart Pointers</h2>\\n<p>Box is a smart pointer that allows to allocate data on the heap\\nin a straighforward way:</p>\\n<pre><code class=\\\"language-rust\\\">let t = (12, \\\"eggs\\\"); // created on the stack\\nlet b = Box::new(t); // created on the heap, but b was stored on the stack\\nprintln!(\\\"{:?}\\\", b);\\n\\nlet x = 5;\\nlet y = &#x26;x;\\nassert_eq!(5, x);\\nassert_eq!(5, *y);\\n\\nlet x = 5;\\nlet y = Box::new(x);\\nassert_eq!(5, x);\\nassert_eq!(5, *y);\\n\\nprintln!(\\\"{:?}\\\", y);\\n</code></pre>\\n<p>Rc is a reference counter that handles and count multiple references to a value.</p>\\n<pre><code class=\\\"language-rust\\\">let s1 = Rc::new(String::from(\\\"Pointer\\\"));\\nlet s2 = s1.clone();\\nlet s3 = s2.clone();\\nprintln!(\\\"{}, {},{}\\\", s1.contains(\\\"Point\\\"), s2, s3.contains(\\\"er\\\"));\\n</code></pre>\\n<p>RefCell allows to mutate data hold in an object whose reference is immutable.</p>\\n<pre><code class=\\\"language-rust\\\">use std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nstruct Flagger {\\n    is_true: RefCell&#x3C;bool>,\\n}\\n\\nlet flag= Flagger { is_true: Rc::new(RefCell::new(true)) };\\n// borrow returns Ref&#x3C;T>\\n// borrow_mut return RefMut&#x3C;T>\\n\\nlet reference = Rc::new(flag.is_true.clone());\\nprintln!(\\\"{:?}\\\", reference);\\n\\nlet mut mut_ref = reference.borrow_mut();\\n*mut_ref = false; // dereference first to access inside\\nprintln!(\\\"{}\\\", mut_ref);\\n</code></pre>\\n<h2>Error handling</h2>\\n<p>Errors split into two categories: </p>\\n<ul>\\n<li>recoverable errors which rely on the result type</li>\\n<li>unrecoverable errors where the panic macro is used. It terminates the current thread.</li>\\n</ul>\\n<p>Example on how to catch an error at opening a file:</p>\\n<pre><code class=\\\"language-rust\\\">let file = File::open(\\\"error.txt\\\");\\nlet file = match file {\\n    Ok(file) => file,\\n    Err(error) => match error.kind() {\\n        ErrorKind::NotFound => match File::create(\\\"error.txt\\\") {\\n            Ok(file_created) => file_created,\\n            Err(err) => panic!(\\\"Cannot create the file: {:?}\\\", err),\\n        },\\n        _ => panic!(\\\"It was some other error kind\\\"),\\n    },\\n};\\n</code></pre>\\n<p>Here is a simple way to panic and get information on error with logs:</p>\\n<pre><code class=\\\"language-rust\\\">let file = File::open(\\\"error.txt\\\").expect(\\\"Error opening the file!\\\");\\n</code></pre>\\n<p>Finally, an error that occurs in a function can be propagated upwards to the calling\\ncontext by adding a question mark to the calling statement like here:</p>\\n<pre><code class=\\\"language-rust\\\">fn open_file() -> Result&#x3C;File, Error> {\\n    let file = File::open(\\\"error.txt\\\")?;\\n    Ok(file)\\n}\\n</code></pre>\\n<h2>Unit test</h2>\\n<pre><code class=\\\"language-rust\\\">#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works() {\\n        let result = 2 + 2;\\n        assert_ne!(result, 5);\\n    }\\n\\n    #[test]\\n    #[should_panic]\\n    fn it_fails(){\\n        panic!(\\\"Test failed!\\\");\\n    }\\n\\n    #[test]\\n    fn call_simple_add(){\\n        assert!(simple_add());\\n    }\\n\\n}\\n\\nfn simple_add() -> bool {\\n    if 2+2 == 4 {\\n        true\\n    } else {\\n        false\\n    }\\n}\\n</code></pre>\\n<h2>Concurrency</h2>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\n\\nfn main() {\\n    let handle = thread::spawn(move || {\\n        println!(\\\"Hello from a thread!\\\")\\n    });\\n\\n    handle.join().unwrap();\\n    println!(\\\"Hello from main\\\");\\n\\n}\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\n\\nfn main() {\\n    let v = vec![1, 2, 3];\\n    let mut thread_handles = Vec::new();\\n\\n    for e in v {\\n        // Here the move keyword is forcing the closure to take ownership:\\n        thread_handles.push(thread::spawn(move || println!(\\\"{:?}\\\", e)));\\n    }\\n\\n    println!(\\\"Main thread!\\\");\\n    \\n    for handle in thread_handles {\\n        handle.join().unwrap();\\n    }\\n}\\n</code></pre>\\n<p>Threads can communicate between each other with channels.\\nA channel has a transmitter and a receiver. A channel\\nis considered closed when either the transmitter or the\\nreceiver is dropped.</p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::mpsc; // multi producer single consumer\\n\\nfn main() {\\n    let (transmitter, receiver) = mpsc::channel();\\n    \\n    let val = String::from(\\\"Transmitting!\\\");\\n    thread::spawn(move || {\\n        transmitter.send(val).unwrap();\\n    });\\n\\n    let msg = receiver.recv().unwrap();\\n    println!(\\\"{}\\\", msg);\\n}\\n</code></pre>\\n<p>Types that implement Send are safe to pass by value to another thread. They can be moved accross threads. </p>\\n<p>Types that implement Sync are safe to pass by non mutable reference to another thread. They can be shared accross threads. </p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::Arc;\\n\\nfn main() {\\n    let rc1 = Arc::new(String::from(\\\"test\\\"));\\n    let rc2 = rc1.clone();\\n    thread::spawn(move || {\\n        rc2;\\n    });\\n}\\n</code></pre>\\n<p>Mutexes allow to manage the access of a variable by several thread.</p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::{Arc, Mutex};\\n\\nfn main() {\\n    let counter = Arc::new(Mutex::new(0));\\n    let mut handles = vec![];\\n    \\n    for _ in 0..8 {\\n        let counter = Arc::clone(&#x26;counter);\\n        let handle = thread::spawn(move || {\\n            let mut num = counter.lock().unwrap();\\n            *num += 1;\\n        });\\n        handles.push(handle);\\n    }\\n\\n    for handle in handles {\\n        handle.join().unwrap();\\n    }\\n    \\n    println!(\\\"{}\\\", counter.lock().unwrap());\\n}\\n</code></pre>\\n<h2>Webassembly</h2>\\n<h3>Setting up of environment</h3>\\n<pre><code class=\\\"language-bash\\\">rustup update\\nrustc --version\\ncargo install cargo-generate\\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\\nnvm install 16.15.0\\n</code></pre>\\n<h3>Starting a project</h3>\\n<p>Run the command:</p>\\n<pre><code class=\\\"language-bash\\\">cargo generate --git https://github.com/rustwasm/wasm-pack-template\\n</code></pre>\\n<p>and enter a project name, e.g. wasm-game-of-life when prompted.</p>\\n<pre><code class=\\\"language-bash\\\">cd wasm-game-of-life\\nwasm-pack build\\nnpm init wasm-app www\\ncd www\\nnpm start\\n</code></pre>\",\"frontmatter\":{\"title\":\"Rust\",\"date\":\"February 06, 2022\",\"path\":\"/rust\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h2>Formatted printing and string formatting with fmt package</h2>\\n<p>Package fmt provides 3 terminal printing functions: </p>\\n<ul>\\n<li>Printf â€” custom format</li>\\n<li>Print â€” simple print</li>\\n<li>Println â€” simple print with a newline</li>\\n</ul>\\n<p>and an F and an S variants of the above functions:</p>\\n<ul>\\n<li>F prints to a data stream: Fprintf, Fprint, Fprintln</li>\\n<li>S prints to a new string: Sprintf, Sprint, Sprintln</li>\\n</ul>\\n<p><em>verb</em>\\t\\t<em>description</em><br>\\n%v\\t\\t\\tdefault<br>\\n%t\\t\\t\\t\\\"true\\\" or \\\"false\\\"<br>\\n%c\\t\\t\\tcharacter<br>\\n%X\\t\\t\\tHex<br>\\n%U\\t\\t\\tUnicode format<br>\\n%e\\t\\t\\tScientific notation  </p>\\n<p><em>Escape Sequence</em>\\t<em>Description</em><br>\\n\\\\\\t\\t\\t\\t\\tBackslash<br>\\n'\\t\\t\\t\\t\\tSingle quote<br>\\n\\\"\\t\\t\\t\\t\\tDouble quote<br>\\n\\\\n\\t\\t\\t\\t\\tNewline<br>\\n\\\\u or \\\\U\\t\\t\\tUnicode (2byee &#x26; 4byte)<br>\\n\\\\x\\t\\t\\t\\t\\tRaw bytes (as hex digits)  </p>\\n<pre><code class=\\\"language-go\\\">fmt.Printf(\\\"%v\\\\n\\\", 8)\\nfmt.Printf(\\\"This is a \\\\\\\"Quote\\\\\\\"\\\\n\\\")\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">func surround(msg string, left, right rune) string {\\n    return fmt.Sprintf(\\\"%c%v%c\\\", left, msg, right)\\n}\\n\\nsurrounded := surround(\\\"this message\\\", '(', ')')\\nfmt.Println(surrounded)\\n</code></pre>\\n<h2>Structures</h2>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\ntype Passenger struct {\\n    name         string\\n    ticketNumber int\\n    boarded      bool\\n}\\n\\ntype Bus struct {\\n    FrontSeat passenger\\n}\\n\\nfunc main() {\\n    var (\\n        bill = Passenger{name: \\\"Bill\\\", ticketNumber: 2}\\n        ella = Passenger{name: \\\"Ella\\\", ticketNumber: 3}\\n    )\\n    fmt.Println(bill, ella)\\n    var heidi Passenger\\n    heidi.name = \\\"Heidi\\\"\\n    heidi.ticketNumber = 4\\n    fmt.Println(heidi)\\n    var vehicle = Bus{FrontSeat: ella}\\n    fmt.Println(vehicle)\\n}\\n</code></pre>\\n<h2>Arrays</h2>\\n<pre><code class=\\\"language-go\\\">Go arrays have fixed size. \\n</code></pre>\\n<h2>Slices</h2>\\n<p>Slices are companion types that work with arrays.\\nThey enable a \\\"view\\\" into an array.\\nViews are dynamic and not fixed in size.\\nFunctions can accept a clice as a function parameter.\\nAny array can be operated upon via slice.</p>\\n<pre><code class=\\\"language-go\\\">mySlice := []int{1, 2, 3}\\nitem1 := mySlice[0]\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">numbers := [...]int{1, 2, 3, 4}\\nslice1 := numbers[:]\\nslice2 := numbers[1:]\\nslice3 := numbers[:1]\\nslice4 := numbers[:2]\\nslice5 := numbers[1:3]\\n</code></pre>\\n<p>The <code>append()</code> function can add additional elements:</p>\\n<pre><code class=\\\"language-go\\\">numbers := [...]int{1, 2, 3, 4}\\nnumbers = append(numbers, 4, 5, 6)\\n</code></pre>\\n<p>3 dots can be used to extend a slice with another slice:</p>\\n<pre><code class=\\\"language-go\\\">part1 := []int{1, 2, 3}\\npart2 := []int{4, 5, 6}\\ncombined := append(part1, part2...)\\n</code></pre>\\n<p>Slices can be preallocated with specific capacities using the make function:</p>\\n<pre><code class=\\\"language-go\\\">slice := make([]int, 10)\\n</code></pre>\\n<p>This saves computation time.</p>\\n<p>The len() function returns the length of any slice;</p>\\n<pre><code class=\\\"language-go\\\">for i:=0; i &#x3C; len(slice); i++ {\\n    // ...\\n}\\n</code></pre>\\n<p>Slices can be multidimensional:</p>\\n<pre><code class=\\\"language-go\\\">board := [][] string {\\n    []string{\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n    {\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n    {\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n}\\nboard[0][0] = \\\"X\\\"\\nboard[0][0] = \\\"O\\\"\\n</code></pre>\\n<h2>Ranges</h2>\\n<p>The range keyword creates an iterator.</p>\\n<pre><code class=\\\"language-go\\\">slice := []string{\\\"Hello\\\", \\\"world\\\", \\\"!\\\"}\\nfor i, element := range slice {\\n    fmt.Println(i, element, \\\":\\\")\\n    for _, ch := range element {\\n        fmt.Printf(\\\"  %q\\\\n\\\", ch)\\n    }\\n}\\n</code></pre>\\n<h2>Maps</h2>\\n<pre><code class=\\\"language-go\\\">myMap1 := make(map[string]int)\\n\\nmyMap2 := map[string]int{\\n    \\\"item 1\\\": 1,\\n    \\\"item 2\\\": 2,\\n    \\\"item 3\\\": 3,\\n}\\n\\nmyMap1[\\\"favorite number\\\"] = 5\\nmissing := myMap1[\\\"age\\\"] // default value\\n\\ndelete (myMap1, \\\"favorite number\\\")\\n\\nprice, found := myMap1[\\\"price\\\"]\\nif !found {\\n    fmt.Println(\\\"price not found\\\")\\n    return\\n}\\n</code></pre>\\n<p>Just like slices, maps can be iterated through using the range keyword:</p>\\n<pre><code class=\\\"language-go\\\">for key, value := range myMap2 {\\n    // ...\\n}\\n</code></pre>\\n<h2>Pointers</h2>\\n<p>An asterisk (*) used with a type indicates the value is a pointer.\\nAn ampersand (&#x26;) creates a pointer from a variable.</p>\\n<pre><code class=\\\"language-go\\\">value := 10\\nvar valuePtr *int // this declaration is often skipped\\nvaluePtr = &#x26;value // value address\\n</code></pre>\\n<p>An asterisk (*) when used with a pointer will dereference the pointer</p>\\n<pre><code class=\\\"language-go\\\">func increment(x *int) {\\n    *x += 1\\n}\\n\\ni := 1\\nincrement(&#x26;i)\\n</code></pre>\\n<p>Example: </p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\ntype SecurityTag struct {\\n    state bool\\n}\\n\\nfunc activate(tag *SecurityTag) {\\n    tag.state = true\\n}\\n\\nfunc deactivate(tag *SecurityTag) {\\n    tag.state = false\\n}\\n\\nfunc checkout(slice []*SecurityTag) {\\n    for _, tag := range slice {\\n        deactivate(tag)\\n    }\\n}\\n\\nfunc printSlice(slice []*SecurityTag) {\\n    fmt.Printf(\\\"%t\\\\n %t\\\\n %t\\\\n %t\\\\n\\\", slice[0].state, slice[1].state, slice[2].state, slice[3].state)\\n}\\n\\nfunc main() {\\n    item1 := SecurityTag{state: true}\\n    item2 := SecurityTag{state: true}\\n    item3 := SecurityTag{state: true}\\n    item4 := SecurityTag{state: true}\\n\\n    items := []*SecurityTag{&#x26;item1, &#x26;item2, &#x26;item3, &#x26;item4}\\n    printSlice(items)\\n\\n    deactivate(&#x26;item1)\\n    printSlice(items)\\n\\n    checkout(items)\\n    printSlice(items)\\n\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” receiver functions</h2>\\n<p>Receiver functions privide the dot notation for structs. This allows to\\ncreate more convenient APIs.</p>\\n<pre><code class=\\\"language-go\\\">type Coordinate struct {\\n    X, Y int\\n}\\n\\nfunc (coord *Coordinate) shiftBy(x, y int) {\\n    coord.X += x\\n    coord.Y += y\\n}\\n\\ncoord := Coordinate{5, 5}\\ncoord.shiftBy(1, 1) // (6, 6)\\n</code></pre>\\n<h2>Idiomatic Go â€” iota</h2>\\n<p>The iota keyword can be used to assign integers to constants.\\nThe two following snippets define and initialize constant\\nOnline to 0, Offline to 1, Maintenance to 2 and Retired to 3.</p>\\n<pre><code class=\\\"language-go\\\">// Short form\\nconst (\\n    Online = iota\\n    Offline\\n    Maintenance\\n    Retired\\n)\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">// Long form:\\nconst (\\n    Online = iota\\n    Offline = iota\\n    Maintenance = iota\\n    Retired = iota\\n)\\n</code></pre>\\n<p>Go allows to skip values as follows:</p>\\n<pre><code class=\\\"language-go\\\">const (\\n    s0 = iota   // 0\\n    -           // 1\\n    -           // 2\\n    s3          // 3\\n    s4          // 4\\n)\\n</code></pre>\\n<p>It is possible to start at a different value:</p>\\n<pre><code class=\\\"language-go\\\">const (\\n    i3 = iota + 3   // 3\\n    i4              // 4\\n    i5              // 5\\n)\\n</code></pre>\\n<h2>Idiomatic Go â€” variadics</h2>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\nfunc sum(nums ...int) int {\\n    sum := 0\\n    for _, n := range nums {\\n        sum += n\\n    }\\n    return sum\\n}\\n\\nfunc main() {\\n    a := []int{1, 2, 3}\\n    b := []int{4, 5, 6}\\n\\n    all := append(a, b...)\\n\\n    answer := sum(all...)\\n    fmt.Println(answer)\\n\\n    answer := sum(1, 2, 3, 4, 5, 6)\\n    fmt.Println(answer)\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” init function</h2>\\n<p>Each package can have it's own init() function. The init function\\nof each will run a single time even when the package is imported\\nseveral times.</p>\\n<p>For instance an init function can initialize an object in file init.go:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nvar EmailExpr *regexp.Regexp\\n\\nfunc init() {\\n    compiled, ok := regexp.Compile(`.+@.+\\\\..+`)\\n    if ok != nil {\\n        panic(\\\"failed to compile regular expression\\\")\\n    }\\n    EmailExpr = compiled\\n    fmt.Println(\\\"regular expression compiled successfully\\\")\\n}\\n</code></pre>\\n<p>The latter object can be used in the main.go like this:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nvar EmailExpr *regexp.Regexp\\n\\nfunc IsValidEmail(addr string) bool {\\n    return EmailExpr.Match([]byte(addr))\\n}\\n\\nfunc main() {\\n    fmt.Println(isValidEmail(\\\"invalid@example\\\"))\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” testing</h2>\\n<p>A unit test for the above main function can be coded in a file\\ncalled <code>main_test.go</code>:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"testing\\\"\\n\\nfunc TestIsValidEmail(t *testing.T) {\\n    data := \\\"email@example.com\\\"\\n    if !IsValidEmail(data) {\\n        t.Errorf(\\\"IsValidEmail(%v)=false, want true\\\", data)\\n    }\\n}\\n</code></pre>\\n<p>Tests can be executed with</p>\\n<pre><code class=\\\"language-bash\\\">go test\\n</code></pre>\\n<p>To execute tests in a specific file execute for instance: </p>\\n<pre><code class=\\\"language-bash\\\">go test -v ./foo/foo_test.go\\n</code></pre>\\n<p>Some functions available in the test package:</p>\\n<ul>\\n<li><code>Fail()</code>: mark the test as failed</li>\\n<li><code>Errorf(string)</code>: fail &#x26; add a message</li>\\n<li><code>FailNow()</code>: mark the test as failed, abort current test</li>\\n<li><code>Fatalf(string)</code>: fail, abort and add a message</li>\\n<li><code>Logf()</code>: equivalent to Printf, but only when test fails</li>\\n</ul>\\n<p>A <a href=\\\"https://yourbasic.org/golang/table-driven-unit-test/\\\">test table</a> can\\nbe nicely coded to test a function with more than one set of data.</p>\\n<h2>Function literals</h2>\\n<p>Function literals also known as anonymous function\\nare functions within a function. They can encapsulate data.</p>\\n<pre><code class=\\\"language-go\\\">func helloWorld() {\\n    fmt.Printf(\\\"Hello, \\\");\\n    world := func() {\\n        fmt.Printf(\\\"World!\\\\n\\\")\\n    }\\n    world()\\n    world()\\n    world()\\n}\\n</code></pre>\\n<p>A function literal can be passed as a parameter to a function: </p>\\n<pre><code class=\\\"language-go\\\">func customMsg(fn func(m string), msg string) {\\n    msg = strings.ToUpper(msg)\\n    fn(msg)\\n}\\n\\nfunc surround() func(msg string) {\\n    return func(msg string) {\\n        fmt.Printf(\\\"%.*s\\\\n\\\", len(msg), \\\"------------\\\"))\\n        fmt.Println(msg)\\n        fmt.Printf(\\\"%.*s\\\\n\\\", len(msg), \\\"------------\\\"))\\n    }\\n}\\n\\ncustomMsg(surround(), \\\"hello\\\")\\n</code></pre>\\n<p>Closures are function literals that access variables\\ndefined outside of their scope.</p>\\n<p>A type alias can be defined for a literal function so\\nthat is is simple to pass it as a parameter to a function: </p>\\n<pre><code class=\\\"language-go\\\">type DiscountFunc func(subTotal float64) float64\\n\\nfunc calculatePrice(\\n        subtotal float64,\\n        discountFn DiscountFunc\\n    ) float64 {\\n        return subTotal - (subTotal * discountFn(subTotal))\\n}\\n</code></pre>\\n<h2>Interfaces</h2>\\n<p>Interfaces allow specifying the behavior of a type.</p>\\n<pre><code class=\\\"language-go\\\">type MyInterface interface {\\n    Function1()\\n    Function2(x int) int\\n}\\n\\ntype MyType int\\nfunc (m MyType) Function1() {}\\nfunc (m MyType) Function2(x int) int {\\n    return x + x\\n}\\n\\nfunc execute(i MyInterface) {\\n    i.Function1()\\n}\\n</code></pre>\\n<p>When a type has all receiver functions required by the\\ninterface, then it is considered implemented.</p>\\n<h4>Standard Library use case: errors</h4>\\n<p>The Error() string function of the errors interface\\nfrom the standard library. The errors.New function returns\\nan Error.</p>\\n<pre><code class=\\\"language-go\\\">import \\\"errors\\\"\\n\\nfunc divide(lhs, rhs int) (int, error) {\\n    if rhs == 0 {\\n        return 0, errors.New(\\\"cannot divide by zero\\\")\\n    } else {\\n        return rhs / lhs, nil\\n    }\\n}\\n</code></pre>\\n<p>Here is the error interface:</p>\\n<pre><code class=\\\"language-go\\\">type error interface {\\n    Error() string\\n}\\n</code></pre>\\n<p>Always implement error as a receiver function:</p>\\n<pre><code class=\\\"language-go\\\">type DivError struct {\\n    a, b int\\n}\\n\\nfunc (d *DivError) Error() string {\\n    return fmt.Sprintf(\\\"Cannot divide by zero: %d / %d\\\", d.a, d.b)\\n}\\n\\nfunc div(a, b int) (int, error) {\\n    if b == 0 {\\n        return 0, &#x26;DivError{a, b}\\n    } else {\\n        return a / b, nil\\n    }\\n}\\n\\nanswer1, err := div(9, 0)\\n\\nif err != nil {\\n    fmt.Println(err)\\n    return\\n}\\n\\nfmt.Println(\\\"The answer is: \\\", answer1)\\n</code></pre>\\n<p>Additional features from errors:</p>\\n<ul>\\n<li>use errors.As() to retrieve and error</li>\\n<li>use errors.Is() to check the error type</li>\\n</ul>\\n<h4>Standard Library use case: Reader &#x26; Writer</h4>\\n<p>Reader &#x26; Writer are interfaces that allow reading from and\\nwriting to I/O sources like: network sockets, files, arbitrary arrays.</p>\\n<pre><code class=\\\"language-go\\\">type Reader interface {\\n    Read(p []byte) (n int, err error)\\n}\\n\\ntype Writer interface {\\n    Write(p []byte) (n int, err error)\\n}\\n</code></pre>\\n<p>Each call to Read() will fill the provided p buffer.\\nThe number of bytes read will be returned as n.\\nWhen all bytes have been read, err will be io.EOF.</p>\\n<p>Using Reader directly requires manually populating a buffer.\\nThe bufio stdlib package provides auto-buffered reads. In practice\\nit is more usual to work with the bufio package instead of the\\nlow level Reader directly as shown comparing the two following approaches:</p>\\n<pre><code class=\\\"language-go\\\">reader := strings.NewReader(\\\"SAMPLE\\\")\\n\\nvar newString strings.Builder\\nbuffer := make([]byte, 4)\\nfor {\\n    numBytes, err := reader.Read(buffer)\\n    chunk := buffer[:numBytes]\\n    newString.Write(chunk)\\n    fmt.Printf(\\\"Read %v bytes: %c\\\\n\\\", numBytes, chunk)\\n    if err == io.EOF {\\n        break\\n    }\\n}\\nfmt.Printf(\\\"%v\\\\n\\\", newString.String())\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">source := strings.NewReader(\\\"SAMPLE\\\")\\nbuffered := bufio.NewReader(source)\\n// can also user buffered.ReadBytes here:\\nnewString, err := buffered.ReadString('\\\\n')\\nif err == io.EOF {\\n    fmt.Println(newString)\\n} else {\\n    fmt.Println(\\\"something went wrong...\\\")\\n}\\n</code></pre>\\n<p>The bufio.Scanner provides more features.\\nIt can automatically read and delimit inputs.</p>\\n<pre><code class=\\\"language-go\\\">// read lines from standard input\\nscanner := bufio.NewScanner(os.Stdin)\\nlines := make([]string, 0, 5)\\nfor scanner.Scan() {\\n    lines = append(lines, scanner.Text())\\n}\\nif scanner.Err() != nil {\\n    fmt.Println(scanner.Err())\\n}\\nfmt.Printf(\\\"Line count: %v\\\\n\\\", len(lines))\\nfor _, line := range lines {\\n    fmt.Printf(\\\"Line: %v\\\\n\\\", line)\\n}\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">printf \\\"these\\\\nare\\\\nsome\\\\nwords\\\" | go run ./scannercode.go\\n</code></pre>\\n<p>Writer is symmetrical with Reader:</p>\\n<pre><code class=\\\"language-go\\\">buffer := bytes.NewBufferString(\\\"\\\")\\nnumBytes, err := buffer.WriteString(\\\"SAMPLE\\\")\\nif err != nil {\\n    fmt.Println(err)\\n} else {\\n    fmt.Printf(\\\"Wrote %v bytes: %c\\\\n\\\", numBytes, buffer)\\n}\\n</code></pre>\\n<h4>Language use case: Type Embedding</h4>\\n<p>Embedded interfaces allow to \\\"embed\\\" an interface into another interface.</p>\\n<pre><code class=\\\"language-go\\\">type Whisperer interface {\\n    Whisper() string\\n}\\n\\n\\ntype Yeller interface {\\n    Yeller() string\\n}\\n\\ntype Talker interface {\\n    Whisperer\\n    Yeller\\n}\\n\\nfunc talk(t Talker) {\\n    fmt.Println(t.Yell())\\n    fmt.Println(t.Whisper())\\n} \\n</code></pre>\\n<p>Embedded structs allow to \\\"embed\\\" a struct into another struct.\\nThe struct will have access to all receiver functions and data\\nof the embedded struct at the top level. This is called\\nfield and method promotion.</p>\\n<pre><code class=\\\"language-go\\\">type Account struct {\\n    accountId int\\n    balance int\\n    name string\\n}\\n\\ntype ManagerAccount struct {\\n    Account\\n}\\n\\nmgrAcct := ManagerAccount{Account{2, 30, \\\"Cassandra\\\"}}\\n</code></pre>\\n<h4>Language use case: Generics</h4>\\n<p>Generics are defined using interfaces, called constraints.\\nFunction parameters and return types are constrained to a\\nspecific set of interfaces:</p>\\n<pre><code class=\\\"language-go\\\">func name[T contraint, U constraintA | constraintB](a T, b U) T {\\n    // ...\\n}\\n</code></pre>\\n<p>Example: </p>\\n<pre><code class=\\\"language-go\\\">func IsEqual[T comparable](a, b T) bool {\\n    return a == b\\n}\\n</code></pre>\\n<p>Tilde can be used to specify that approximation on a type is allowed:</p>\\n<pre><code class=\\\"language-go\\\">type Integer32 interface {\\n    ~int32 | ~uint32\\n}\\n\\ntype MyInt int32\\n</code></pre>\\n<h2>Using defer</h2>\\n<pre><code class=\\\"language-go\\\">func one() {\\n    fmt.Println(\\\"1\\\")\\n}\\n\\nfunc two() {\\n    fmt.Println(\\\"2\\\")\\n}\\n\\nfunc sample() {\\n    fmt.Println(\\\"Begin\\\")\\n    defer one()\\n    defer two()\\n    fmt.Println(\\\"End\\\")\\n}\\n</code></pre>\\n<h2>Concurrency â€” goroutines</h2>\\n<pre><code class=\\\"language-go\\\">func count(amount int) {\\n    for i := 1; i &#x3C;= amount; i++ {\\n        time.Sleep(100 * time.Millisecond)\\n        fmt.Println(i)\\n    }\\n}\\n\\nfunc main() {\\n    go count(5)\\n    fmt.Println(\\\"wait for goroutine\\\")\\n    time.Sleep(1000 * time.Millisescond)\\n    fmt.Println(\\\"end program\\\")\\n}\\n</code></pre>\\n<p>Goroutines allow functions and closures to un concurrently.\\nUse the go keyword to create a new goroutine.  </p>\\n<p>The function that starts a goroutine will not wait for it to finish.\\nBoth the the calling function and goroutine will run to completion.  </p>\\n<p>Closure captures are shared among all goroutines, making it easy\\nto parallelize code.</p>\\n<h2>Concurrency â€” channels</h2>\\n<p>Channels are one-way communication pipes. They have\\na send/write end and a receive/read end.\\nThe ends can be duplicated across goroutines.\\nBidirectional communication can be accomplished by using\\nmore channels.  </p>\\n<p>Buffered channels are non-blocking, unbuffered channels\\nwill block.</p>\\n<pre><code class=\\\"language-go\\\">channel := make(chan int)\\n\\n// Send to channel\\ngo func() { channel &#x3C;- 1 }()\\ngo func() { channel &#x3C;- 2 }()\\ngo func() { channel &#x3C;- 3 }()\\n\\n// Receive from channel\\nfirst := &#x3C;-channel\\nsecond := &#x3C;-channel\\nthird := &#x3C;-channel\\n\\nfmt.Println(first, second, third)\\n</code></pre>\\n<p>The time package can be combined with select\\nto create timeouts:</p>\\n<pre><code class=\\\"language-go\\\">one := make(chan int)\\ntwo := make(chan int)\\n\\nfor {\\n    select {\\n        case o := &#x3C;-one:\\n            fmt.Println(\\\"one:\\\", o)\\n        case t := &#x3C;-two:\\n            fmt.Println(\\\"two:\\\", t)\\n        case o := &#x3C;-time.After(300 * time.Millisecond):\\n            fmt.Println(\\\"timed out\\\")\\n            return\\n    }\\n}\\n</code></pre>\\n<h2>Concurrency â€” synchronization</h2>\\n<p>Managing data accross multiple goroutines\\ncan become problematic and hard to debug because:  </p>\\n<ul>\\n<li>multiple goroutines can change the same data leading\\nto unpredictable results  </li>\\n<li>using channels to communicate is not always ideal  </li>\\n</ul>\\n<p>Synchronization solves this issue:  </p>\\n<ul>\\n<li>enables waiting for goroutines to finish  </li>\\n<li>prevents multiple goroutines from modifying data\\nsimultaneously  </li>\\n</ul>\\n<p>A mutex provides a way to lock and unlock data. It\\nallows to work with multiple goroutines.</p>\\n<pre><code class=\\\"language-go\\\">import \\\"sync\\\"\\n\\ntype SyncedData struct {\\n    inner map[string] int\\n    mutex sync.Mutex\\n}\\n\\nfunc (d *SyncedData) Insert(k string, v int) {\\n    d.mutex.Lock()\\n    defer d.mutex.Unlock()\\n    d.inner[k] = v\\n}\\n\\nfunc (d *SyncedData) Get(k string) int {\\n    d.mutex.Lock()\\n    defer d.mutex.Unlock()\\n    return d.inner[k]\\n}\\n\\nfunc main() {\\n    data := SyncedData{ inner: make(map[string]int) }\\n    data.Insert(\\\"sample\\\", 5)\\n    data.Insert(\\\"test\\\", 2)\\n    fmt.Println(data.Get(\\\"sample\\\"))\\n    fmt.Println(data.Get(\\\"test\\\"))\\n}\\n</code></pre>\\n<p>Wait groups enable an application to wait for goroutines\\nto finish. They operate by incrementing a counter whenever\\na goroutine is added, and decrementing when it finishes.\\nWaiting on the group will block execution until the\\ncounter is 0.</p>\\n<pre><code class=\\\"language-go\\\">var wg sync.WaitGroup\\nsum := 0\\nfor i := 0; i &#x3C; 20; i++ {\\n    wg.Add(1)\\n    value := i\\n    go func() {\\n        defer wg.Done()\\n        sum += value\\n    }()\\n}\\nwg.Wait()\\nfmt.Println(\\\"sum = \\\", sum)\\n</code></pre>\\n<h2>Cross compiling and cgo</h2>\\n<p>When not cross compiling, cgo is enabled by default. This is\\nthe case when executing a command like:</p>\\n<pre><code class=\\\"language-sh\\\">go build -o main main.go\\n</code></pre>\\n<p>Links pertaining to the compiled file can be displayed with:</p>\\n<pre><code class=\\\"language-sh\\\">ldd main\\n</code></pre>\\n<p>Compilation without cgo can be performed with:</p>\\n<pre><code class=\\\"language-sh\\\">CGO_ENABLED=0 go build -o main-nocgo main.go\\n</code></pre>\\n<p>Cross compilation for a given os/architecture combination say darwin/amd64 can be done\\nwith:</p>\\n<pre><code class=\\\"language-sh\\\">GOOS=darwin ARCH=amd64 go build -o main-darwin64 main.go\\n</code></pre>\\n<p>Available combinations can be displayed with:</p>\\n<pre><code class=\\\"language-sh\\\">go tool dist list\\n</code></pre>\",\"id\":\"C:/Users/nicolas.peron/github.com/nperon/workshop/src/pages/2022-06-14-go/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-06-14T14:24:43.180Z\",\"path\":\"/go\",\"title\":\"Go\",\"excerpt\":\"Go\",\"tags\":[\"go\"]}},\"next\":{\"html\":\"<p>The following few steps can be taken as a quick start to Argo CD\\nthat can be done with a local cluster, say minikube. </p>\\n<h2>Starting argocd non HA with cluster privilege</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n</code></pre>\\n<h2>Displaying argocd initial admin secret</h2>\\n<pre><code class=\\\"language-zsh\\\">ENCODED=$(kubectl -n argocd get secret argocd-initial-admin-secret -o yaml | yq .data.password)\\necho $ENCODED\\necho $ENCODED | base64 --decode\\n</code></pre>\\n<h2>Exposing argocd server with a port forward argocd server pod</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl port-forward svc/argocd-server -n argocd 8080:443\\n</code></pre>\\n<p>Open browser at <a href=\\\"https://localhost:8080\\\">https://localhost:8080</a></p>\\n<h2>Using ArgoCD CLI</h2>\\n<p>CLI allows to manage everything: applications, repos, clusters, tasks, projects...</p>\\n<pre><code class=\\\"language-zsh\\\">argocd login localhost:8080\\nargocd cluster list\\n</code></pre>\\n<h2>Applications</h2>\\n<p>Given the following yaml content in a file called <code>application.yml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>run the following commands:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application.yml\\n</code></pre>\\n<p>And then verify the application was created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get application -n argocd\\n</code></pre>\\n<p>Other app based on helm can be started the same way:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_helm_options.yml\\n</code></pre>\\n<p>where <code>application_helm_options.yml</code> has a content like:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: helm-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: helm-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: helm-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    helm:\\n      releaseName: my-release\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Finally, an application loaded recursively from\\na local directory can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_subdirectories_options.yml\\n</code></pre>\\n<p>with a file <code>application_subdirectories_options.yml</code>\\nwith a content:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: directory-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: directory-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Here are ArgoCD options which can be adjusted with kustomize:</p>\\n<ul>\\n<li>Name prefix: appended to resources</li>\\n<li>Name suffix: appended to resources</li>\\n<li>Images: to override images</li>\\n<li>Common labels: set labels on all resources</li>\\n<li>Common annotations: set annotations on all resources</li>\\n<li>Version: explicitly set kustomize version</li>\\n</ul>\\n<p>The manifest below called for instance <code>application_kustomize.yaml</code> is an example of an kustomize argocd application. Two options are adjusted with kustomize: namePrefix\\nand a commonLabel with a key of app and a value of demo. </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: kustomize-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: kustomize-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: kustomize-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    kustomize:\\n      namePrefix: staging-\\n      commonLabels:\\n        app: demo\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Application can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_kustomize.yml\\n</code></pre>\\n<p>Note that Argo CD automatically detects that\\nit is a Kustomize application.</p>\\n<h2>Projects</h2>\\n<p>Display info on by default project:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>Now a project can be created by running </p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f ./project.yaml\\n</code></pre>\\n<p>with a file called project.yaml: </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: demo-project\\n  namespace: argocd\\nspec:\\n  description: Demo Project\\n  sourceRepos:\\n  - '*'\\n\\n  destinations:\\n  - namespace: '*'\\n    server: '*'\\n\\n  clusterResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n\\n  namespaceResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n</code></pre>\\n<p>Display info on projects again with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>An application can be defined to start in the project thus created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f './application.yml'\\n</code></pre>\\n<p>with the following content for application.yml:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook-demo-project\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook-demo-project\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: demo-project\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<h2>Sync</h2>\\n<p>Automated syncing can be enabled by declaring a syncPolicy in the\\nmanifest of the application. Or by adding a <code>sync-policy automated</code>\\nflag to a cli <code>argocd app create</code> command. There is also a\\nSYNC POLICY setting which can be set to Automatic in the Web UI.</p>\\n<p>Example of an application manifest:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: auto-sync-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: auto-sync-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    automated: {}\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<ul>\\n<li>\\n<p>Additional features: </p>\\n<ul>\\n<li>automated pruning</li>\\n<li>self healing</li>\\n</ul>\\n</li>\\n<li>\\n<p>Sync Options with at the resource level with annotations or at the\\napplication level with syncOptions (in syncPolicy):</p>\\n<ul>\\n<li>Prune = false</li>\\n<li>Validate = false</li>\\n</ul>\\n</li>\\n<li>\\n<p>Selective syncing at the application level only with syncOptions:\\nApplyOutOfSyncOnly=true</p>\\n</li>\\n<li>\\n<p>Argo waves with PruneLast=true at application or resource level.</p>\\n</li>\\n<li>\\n<p>Replacing resources: by default Argo CD uses <code>kubectl apply</code> to\\ndeploy resources changes\\nIn some cases, you need to replace/recreate the resources.\\nArgoCD can do this by using replace=true. It can be done at application level\\nwith a Replace of true in syncOptions. It can be also done at resource level\\nwith an annotation like <code>argocd.argoproj.io/sync-options: Replace=true</code></p>\\n</li>\\n<li>\\n<p>sync can be configured to fail if resource is found in other applications\\nby using FailOnSharedResource=true</p>\\n</li>\\n</ul>\",\"id\":\"C:/Users/nicolas.peron/github.com/nperon/workshop/src/pages/2022-08-14-argocd/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-08-14T22:51:00.823Z\",\"path\":\"/argocd\",\"title\":\"Argo CD\",\"excerpt\":\"\",\"tags\":[\"continuous delivery\",\"cloud\",\"devops\",\"gitops\",\"kubernetes\",\"kustomize\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---rust-cb055b0c7fbdb012cb66.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h2>Cargo commands</h2>\\n<p>Command to create a project:</p>\\n<pre><code class=\\\"language-bash\\\">cargo new hello\\n</code></pre>\\n<p>You can compile and run the project now with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo run\\n</code></pre>\\n<p>This builds the project in a directory called <code>target/debug</code>.\\nTo build the project in the <code>target/release</code> directory intended for prod, just run:</p>\\n<pre><code class=\\\"language-bash\\\">cargo run --release\\n</code></pre>\\n<p>A good tip to improve the code with idiomatic rust coding hints/warnings is to run:</p>\\n<pre><code class=\\\"language-bash\\\">cargo clippy\\n</code></pre>\\n<p>Here is a command to view the standard library in the default browser:</p>\\n<pre><code class=\\\"language-bash\\\">rustup doc --std\\n</code></pre>\\n<h3>Coding modules</h3>\\n<p>Crates are about code sharing between projects while modules are about\\ncode sharing within a project. </p>\\n<p>This can take place in a package library. This can be created with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo new todo --lib\\n</code></pre>\\n<p>Cargo modules is a useful tool to manage modules. It can be installed with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo install cargo-modules\\n</code></pre>\\n<p>Then, project's modules tree can be displayed with:</p>\\n<pre><code class=\\\"language-bash\\\">cargo modules generate tree\\n</code></pre>\\n<p>The displayed tree can be refined with options:</p>\\n<pre><code class=\\\"language-bash\\\">cargo modules generate tree --with-types\\n</code></pre>\\n<h2>Strings</h2>\\n<p>String slices refered to as <code>str</code>\\nare almost always handled in the shape of borrowed string slices <code>&#x26;str</code>.\\nSee also the Rust documentation on <a href=\\\"https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\\\">references and borrowing</a>.</p>\\n<p>A string literal stated\\n<code>let msg = \\\"Hello ðŸŒŽ\\\";</code>\\nis a borrowed string slice.</p>\\n<p>The other string type is String.\\nData in a borrowed string slice cannot be modified\\nwhile data in a String can be modified.</p>\\n<p>A String can be obtained by applying the to_string() method on a\\nborrowed string slice:</p>\\n<pre><code>let msg = \\\"abðŸŽ‰\\\".to_string();\\n</code></pre>\\n<p>or else by passing the borrowed string slice to String::from:</p>\\n<pre><code>let msg = String::from(\\\"abðŸŽ‰\\\");\\n</code></pre>\\n<p>Internally, a borrowed string slice is made up of a pointer to some byte and\\na length. The length is the number of unicode characters in the string.</p>\\n<p>Bytes can be extracted from a borrowed string slice with the bytes() method: <code>word.bytes();</code></p>\\n<p>An iterator on unicode scalars can be built with <code>word.chars();</code></p>\\n<p>Additionally, an iterator on graphemes can be retrieved using a package called unicode-segmentation with:</p>\\n<p><code>graphemes(my_string, true)</code></p>\\n<p>A given item in the graphemes can then be accessed with by appending a statement like<code>.nth(3)</code></p>\\n<p>All of the helper methods to manipulate String objects are documented\\n<a href=\\\"https://doc.rust-lang.org/std/string/struct.String.html#method.bytes\\\">here</a>.</p>\\n<p>A String can be converted into a &#x26;str with the <code>.as_str()</code> method.\\nIt follows that string slices can manipulated in the shape of String objects\\nand the latter can be converted back into string slices with <code>as_str()</code>.\\nFor instance two <code>&#x26;str</code> can be concatenated into a string c with:</p>\\n<pre><code class=\\\"language-bash\\\">let a = \\\"Hello\\\";\\nlet b = \\\" World\\\";\\nlet c = format!(\\\"{}{}\\\", a, b);\\n</code></pre>\\n<h2>String literals</h2>\\n<pre><code class=\\\"language-rust\\\">let rust = \\\"\\\\x52\\\\x75\\\\x73\\\\x74\\\";\\nprintln!(\\\"{}\\\", rust);\\n</code></pre>\\n<h2>Struct with impl</h2>\\n<pre><code class=\\\"language-rust\\\">struct Square {\\n    width: u32,\\n    height: u32,\\n}\\n\\nimpl Square {\\n    fn area(&#x26;self) -> u32 {\\n        self.width * self.height\\n    }\\n\\n    fn whats_my_width(&#x26;self) -> u32 {\\n        self.width\\n    }\\n\\n    fn change_width(&#x26;mut self, new_width: u32){\\n        self.width = new_width;\\n    }\\n}\\n</code></pre>\\n<h2>Struct with Trait</h2>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct RedFox {\\n    enemy: bool,\\n    life: u32,\\n}\\n\\ntrait Noisy {\\n    fn get_noise(&#x26;self) -> &#x26;str;\\n}\\n\\nimpl Noisy for RedFox {\\n    fn get_noise(&#x26;self) -> &#x26;str { \\\"Meow?\\\" }\\n}\\n\\nfn print_noise&#x3C;T: Noisy>(item: T) {\\n    println!(\\\"\\\", item.get_noise());\\n}\\n\\nimpl Noisy for u8 {\\n    fn get_noise(&#x26;self) -> &#x26;str { \\\"BYTE!\\\" }\\n}\\n\\nfn main() {\\n    print_noise(5_u8); // prints \\\"BYTE!\\\"\\n}\\n</code></pre>\\n<p>There are two other types of Struct. One is the tuple like Struct:</p>\\n<pre><code class=\\\"language-rust\\\">struct Coordinates(i32, i32, i32);\\n</code></pre>\\n<p>The other is the unit like Struct which is useful when combined with Traits:</p>\\n<pre><code class=\\\"language-rust\\\">struct UnitStruct;\\n</code></pre>\\n<h2>Utility Traits</h2>\\n<ul>\\n<li>The Drop Trait:</li>\\n</ul>\\n<pre><code class=\\\"language-rust\\\">struct Course {\\n    headline: String,\\n    author: String,\\n}\\n\\nimpl Drop for Course {\\n    fn drop(&#x26;mut self) {\\n        println!(\\\"Dropping: {}\\\", self.author);\\n    }\\n}\\n\\nfn main() {\\n    let course1 = Course{ headline: String::from(\\\"Headline!\\\"), author: String::from(\\\"Tyler\\\"), };\\n\\n    drop(course1);\\n}\\n</code></pre>\\n<ul>\\n<li>The Clone Trait which is for types that can make copies of themselves :</li>\\n</ul>\\n<pre><code class=\\\"language-rust\\\">trait Clone: Sized {\\n    fn clone(&#x26;self) -> Self;\\n    fn clone_from(&#x26;mut self, source: &#x26;Self) {\\n        *self = source.clone()\\n    }\\n}\\n</code></pre>\\n<ul>\\n<li>\\n<p>Copy is a shallow Clone</p>\\n</li>\\n<li>\\n<p>From and Into, plus: TryFrom and TryInto</p>\\n</li>\\n</ul>\\n<p><code>fn into(self) -> T</code>: take self and returns a value of type T.</p>\\n<p><code>fn from(T) -> Self</code>: take a value of type T and returns self.</p>\\n<ul>\\n<li>Arithmetics: the Add Trait</li>\\n</ul>\\n<pre><code class=\\\"language-bash\\\">use std::ops::Add;\\n\\n#[derive(Debug)]\\nstruct Point&#x3C;T> {\\n    x: T,\\n    y: T\\n}\\n\\nfn main() {\\n    let coord = Point{ x: 5.0, y: 5.0 };\\n    let coord2 = Point{ x: 1.0, y: 2.0 };\\n    let sum = coord + coord2;\\n    println!(\\\"{:?}\\\", sum);\\n}\\n\\nimpl&#x3C;T> Add for Point&#x3C;T>\\n    where\\n    T: Add&#x3C;Output = T> {\\n        type Output = Self;        \\n        fn add(self, rhs: Self) -> Self {\\n            Point {\\n                x: self.x + rhs.x,\\n                y: self.y + rhs.y,\\n            }\\n        }\\n    }\\n</code></pre>\\n<ul>\\n<li>\\n<p>Fn is a family of closures and functions that you can call multiple times without restrictions. It borrows values from the environment immutably. It includes all fn functions.</p>\\n</li>\\n<li>\\n<p>FnMut is a family of closures and functions that you can call multiple times if the closure itself is declared mut. It immutably borrows values.</p>\\n</li>\\n<li>\\n<p>FnOnce is a family of closures that can be called once if the caller owns the closure. The closure cannot take ownership of the same variables more than once.</p>\\n</li>\\n</ul>\\n<p>Therefore, every Fn meets the requirements for FnMut and every FnMut meets the requirements for FnOnce. It means that Fn is the most exclusive and the most powerful in this set of three Traits.</p>\\n<p>Examples: </p>\\n<ul>\\n<li>\\n<p>|| drop(v) FnOnce  ---> FnOnce</p>\\n</li>\\n<li>\\n<p>|args| v.contains(arg) ---> Fn</p>\\n</li>\\n<li>\\n<p>|args| v.push(arg)  ---> FnMut</p>\\n</li>\\n<li>\\n<p>Iterator</p>\\n</li>\\n</ul>\\n<h2>Lifetimes</h2>\\n<p>Every reference has a Lifetime. Most of the time, Lifetimes are implicit and inferred.</p>\\n<pre><code class=\\\"language-rust\\\">fn longest&#x3C;'a>(x: &#x26;'a str, y: &#x26;'a str) -> &#x26;'a str {\\n    if x.len() > y.len() {\\n        x\\n    } else {\\n        y\\n    }\\n}\\n</code></pre>\\n<p>Syntax for lifetime in a struct is as follows:</p>\\n<pre><code class=\\\"language-rust\\\">struct MyString&#x3C;'a> {\\n    text: &#x26;'a str\\n}\\n</code></pre>\\n<p>Here is an example of a variable defined with a static lifetime:</p>\\n<pre><code class=\\\"language-rust\\\">let s: &#x26;'static str = \\\"I have static lifetime\\\";\\n</code></pre>\\n<h2>Vectors</h2>\\n<pre><code class=\\\"language-rust\\\">let mut v: Vec&#x3C;i32> = Vec::new();\\nv.push(2);\\nv.push(4);\\nv.push(6);\\nlet x = v.pop();    // x is 6\\nprintln(\\\"{}\\\", v[1]);// prints \\\"4\\\"\\nlet mut u = vec![2, 4, 6];\\n</code></pre>\\n<p>Other ways to instanciate vectors: </p>\\n<pre><code class=\\\"language-rust\\\">let vect= Vec::&#x3C;i32>::with_capacity(2);\\nprintln!(\\\"{}\\\", vect.capacity());\\n\\nlet v: Vec&#x3C;i32> = (0..5).collect();\\nprintln!(\\\"{:?}\\\", v);\\n</code></pre>\\n<p>Vector API examples:</p>\\n<pre><code class=\\\"language-rust\\\">let mut nums: Vec&#x3C;i32> = vec![];\\nnums.push(1);\\nnums.push(2);\\nnums.push(3);\\n\\nlet pop = nums.pop(); // returns Option&#x3C;T>: None or Some(T)\\nprintln!(\\\"{:?}\\\", pop);\\nlet number = pop.unwrap();\\nprintln!(\\\"{}\\\", number);\\n\\nlet two = nums[1]; // copy\\n// &#x26;nums[1], creates a reference if copy is not available \\n// (here we get a copy since i32 is a primitive type)\\nprintln!(\\\"{}\\\", two);\\n\\nlet one = nums.first(); // return an Option&#x3C;T> \\n                        // so None if nums is empty, else Some&#x3C;T>\\nprintln!(\\\"{:?}\\\", one);\\n\\n// .last\\n// .first_mut and .last_mut will borrow mutable references\\n\\nprintln!(\\\"{}\\\", nums.len()); // return a value of length\\nprintln!(\\\"{}\\\", nums.is_empty()); // bool\\n\\nnums.insert(0, 10);\\nnums.insert(3, 12);\\nnums.insert(2, 25);\\n\\nnums.remove(3);\\n\\nnums.sort();\\nprintln!(\\\"{:?}\\\", nums);\\n\\nnums.reverse();\\nprintln!(\\\"{:?}\\\", nums);\\n\\nnums.shuffle(&#x26;mut thread_rng());\\nprintln!(\\\"{:?}\\\", nums);\\n</code></pre>\\n<h2>Iterators</h2>\\n<p>Vec is an example of a standard object that implements the Iterator Trait.</p>\\n<p>Example 1:</p>\\n<pre><code class=\\\"language-rust\\\">let vec2 = vec![1, 2, 3];\\nlet mut iter = (&#x26;vec2).into_iter();\\nwhile let Some(v) = iter.next() {\\n    println!(\\\"{}\\\", v);\\n}\\n</code></pre>\\n<p>Example 2:</p>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct Item {\\n    name: String,\\n}\\n\\nfn check_inventory(items: Vec&#x3C;Item>, product: String) -> Vec&#x3C;Item> {\\n    items.into_iter().filter(|i| i.name == product).collect()\\n}\\n\\nfn main() {\\n    let mut vec: Vec&#x3C;Item> = Vec::new();\\n    vec.push(Item { name: String::from(\\\"coat\\\") });\\n    vec.push(Item { name: String::from(\\\"shirt\\\") });\\n    vec.push(Item { name: String::from(\\\"shorts\\\") });\\n    vec.push(Item { name: String::from(\\\"shoes\\\") });\\n\\n    let checked = check_inventory(vec, String::from(\\\"shirt\\\"));\\n    println!(\\\"{:?}\\\", checked);\\n}\\n</code></pre>\\n<p>Example 3:</p>\\n<pre><code class=\\\"language-rust\\\">#[derive(Debug)]\\nstruct Range {\\n    start: u32,\\n    end: u32,\\n}\\n\\nimpl Iterator for Range {\\n    type Item = u32;\\n    fn next(&#x26;mut self) -> Option&#x3C;Self::Item> {\\n        if self.start >= self.end {\\n            return None;\\n        }\\n        let result = Some(self.start);\\n        self.start += 1;\\n        result\\n    }\\n}\\n\\nfn main() {\\n    let mut range = Range {start: 0, end: 10};\\n    // for r in range {\\n    //     println!(\\\"{}\\\", r);\\n    // }\\n\\n    let vec: Vec&#x3C;u32> = range.filter(|x| x % 2 == 0).collect();\\n    println!(\\\"{:?}\\\",vec);\\n}\\n</code></pre>\\n<h2>Slices</h2>\\n<pre><code class=\\\"language-rust\\\">let v: Vec&#x3C;i32> = (0..5).collect();\\nprintln!(\\\"{:?}\\\", v);\\n\\nlet sv: &#x26;[i32] = &#x26;v[2..4];\\nprintln!(\\\"{:?}\\\", sv);\\n</code></pre>\\n<p>A slice is a fat pointer i.e. a non owning reference to a <strong>range</strong> of consecutive values.</p>\\n<h2>Hashmaps</h2>\\n<pre><code class=\\\"language-rust\\\">let mut h: HashMap&#x3C;u8, bool> = HashMap::new();\\nh.insert(5, true);\\nh.insert(6, false);\\nlet have_five = h.remove(&#x26;5).unwrap();\\n</code></pre>\\n<p>Hashmap API examples:</p>\\n<pre><code class=\\\"language-rust\\\">let mut hm = HashMap::new();\\nhm.insert(1, 1);\\nhm.insert(5, 2);\\nhm.insert(30, 3);\\nlet old = hm.insert(30, 4);\\nprintln!(\\\"{:?}\\\", hm);\\nprintln!(\\\"{:?}\\\", old);\\n\\nprintln!(\\\"{:?}\\\", hm.contains_key(&#x26;8));\\nprintln!(\\\"{:?}\\\", hm.get(&#x26;5));\\n\\nlet one = hm.remove(&#x26;1);\\nprintln!(\\\"{:?}\\\", one);\\n\\nlet removed = hm.remove_entry(&#x26;5);\\nprintln!(\\\"{:?}\\\", removed);\\n\\nhm.clear();\\nprintln!(\\\"{}\\\", hm.is_empty());\\n</code></pre>\\n<p>Other collections: VecDeque, LinkedList, HashSet, BinaryHeap, BTreeMap, BTreeSet</p>\\n<h2>HashSets</h2>\\n<pre><code class=\\\"language-rust\\\">let mut hs = HashSet::new();\\nhs.insert(1);\\nhs.insert(2);\\nhs.insert(3);\\nhs.insert(4);\\nhs.remove(&#x26;2);\\nfor x in hs.iter() {\\n    println!(\\\"inter: {}\\\", x);\\n}\\n\\nlet mut hs2 = HashSet::new();\\nhs2.insert(1);\\nhs2.insert(3);\\nhs2.insert(5);\\nhs2.insert(7);\\nfor x in hs.intersection(&#x26;hs2) {\\n    println!(\\\"intersection: {}\\\", x);\\n}\\n\\nlet intersection = &#x26;hs &#x26; &#x26;hs2;\\nfor x in intersection {\\n    println!(\\\"short hand way: {}\\\", x);\\n}\\n\\nlet union = &#x26;hs | &#x26;hs2;\\nfor x in union {\\n    println!(\\\"union: {}\\\", x);\\n}\\n</code></pre>\\n<h2>Enums</h2>\\n<pre><code class=\\\"language-rust\\\">enum Color {\\n    Red,\\n    Green,\\n    Blue,\\n}\\nlet color = Color::Red;\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">enum DispenserItem {\\n    Empty,\\n    Ammo(u8),\\n    Things(String, i32),\\n    Place {x: i32, y: i32},\\n}\\n\\nuse DispenserItem::*;\\nlet item1 = Ammo(69);\\nlet item2 = Things(\\\"hat\\\".to_string(), 7);\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">enum Pet {dog, cat, fish}\\n\\nimpl Pet {\\n    fn what_am_i(self) -> &#x26;'static str {\\n        match self {\\n            Pet::dog => \\\"I am a dog\\\",\\n            Pet::cat => \\\"I am a cat\\\",\\n            Pet::fish => \\\"I am a fish\\\",\\n        }\\n    }\\n}\\n</code></pre>\\n<h3>The rust predefined Option enum</h3>\\n<pre><code class=\\\"language-rust\\\">enum Option&#x3C;T> {\\n    Some(T),\\n    None,\\n}\\n\\nlet mut x: Option&#x3C;i32> =  None;\\nx = Some(5);\\nx.is_some(); // true\\nx.is_none(); false\\nfor i in x {\\n    println!(\\\"{}\\\", i); // prints 5\\n}\\n</code></pre>\\n<p>The match expression handles the case when we can have Some<T> or Node:</p>\\n<pre><code class=\\\"language-rust\\\">enum Pet {dog, cat, fish}\\n\\nfn main () {\\n    let dog = Pet::dog;\\n    println!(\\\"{}\\\", dog.what_am_i());\\n\\n    let some_number = Some(5);\\n    let some_string = Some(\\\"a string\\\");\\n    let nothing: Option&#x3C;i32> = None;\\n\\n    let x: i32 = 5;\\n    let y: Option&#x3C;i32> = Some(5);\\n\\n    let sum = x + y;\\n\\n    let five = Some(5);\\n    let six = plus_one(five);\\n    let none = plus_one(None);\\n\\n    println!(\\\"{:?}\\\", six);\\n\\n    let noneUnw = None.unwrap_or(7);\\n    println!(\\\"unw: {:?}\\\", noneUnw);\\n\\n    what_pet(\\\"dog\\\");\\n    what_pet(\\\"cat\\\");\\n    what_pet(\\\"cow\\\");\\n}\\n\\nfn plus_one(x: Option&#x3C;i32>) -> Option&#x3C;i32> {\\n    match x {\\n        None => None,\\n        Some(i) => Some(i + 1),\\n    }\\n}\\n\\nfn plus_one_unw(x: Option&#x3C;i32>) -> i32 {\\n    match x {\\n        None => 0,\\n        Some(i) => i + 1,\\n    }\\n}\\n\\nfn what_pet(input: &#x26;str) {\\n    match input {\\n        \\\"dog\\\" => println!(\\\"I have a dog!\\\"),\\n        \\\"fish\\\" => println!(\\\"I have a fish!\\\"),\\n        \\\"cat\\\" => println!(\\\"I have a cat!\\\"),\\n        _ => println!(\\\"I have no clue what pet I have\\\"),\\n    }\\n}\\n</code></pre>\\n<h3>The rust predefined Result enum</h3>\\n<pre><code class=\\\"language-rust\\\">enum Result&#x3C;T, E> {\\n    Ok(T),\\n    Err(E),\\n}\\n</code></pre>\\n<p>Example with Result:</p>\\n<pre><code class=\\\"language-rust\\\">use std::fs::File;\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.unwrap();\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.expect(\\\"error message\\\");\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    let f = res.is_ok() {\\n        let f = res.unwrap();\\n    }\\n}\\n\\nfn main() {\\n    let res = File::open(\\\"foo\\\");\\n    match res {\\n        Ok(f) => { /* do stuff */ },\\n        Err(e) => { /* do stuff */ },\\n    }\\n}\\n</code></pre>\\n<h3>Ownership, references  &#x26; borrowing</h3>\\n<p>There are 3 rules to ownership:</p>\\n<ol>\\n<li>Each value has an owner</li>\\n<li>There is only one owner of a value</li>\\n<li>Value gets dropped if its owner goes out of scope</li>\\n</ol>\\n<pre><code class=\\\"language-rust\\\">x: &#x26;mut i32\\n*x // a mutable i32\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">x: &#x26;i32\\n*x: // an immutable i32\\n</code></pre>\\n<p>At any time, it is possible to have one mutable reference\\nor any number of immutable references to a given value.</p>\\n<p>A borrowed variable passed to a function can be dereferenced in two ways.\\nThe first way is automated deferencing:</p>\\n<pre><code class=\\\"language-rust\\\">fn do_stuff(s: &#x26;mut String) {\\n    s.insert_str(0, \\\"Hi, \\\");\\n}\\n</code></pre>\\n<p>And the second way is manual:</p>\\n<pre><code class=\\\"language-rust\\\">fn do_stuff(s: &#x26;mut String) {\\n    *s = String::from(\\\"Replacement\\\")\\n}\\n</code></pre>\\n<h2>Raw Pointers</h2>\\n<p><a href=\\\"https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/\\\">Programming Rust, 2nd Ed</a>:</p>\\n<p><em>Rust also has the raw pointer types *mut T and *const T. Raw\\npointers really are just like pointers in C++. Using a raw\\npointer is unsafe, because Rust makes no eï¬€ort to track what\\nit points to. For example, raw pointers may be null, or they\\nmay point to memory that has been freed or that now\\ncontains a value of a diï¬€erent type.</em> </p>\\n<p><em>All the classic pointer\\nmistakes of C++ are oï¬€ered for your enjoyment.\\nHowever, you may only dereference raw pointers within an\\nunsafe block. An unsafe block is Rustâ€™s opt-in mechanism for\\nadvanced language features whose safety is up to you.</em></p>\\n<h2>Smart Pointers</h2>\\n<p>Box is a smart pointer that allows to allocate data on the heap\\nin a straighforward way:</p>\\n<pre><code class=\\\"language-rust\\\">let t = (12, \\\"eggs\\\"); // created on the stack\\nlet b = Box::new(t); // created on the heap, but b was stored on the stack\\nprintln!(\\\"{:?}\\\", b);\\n\\nlet x = 5;\\nlet y = &#x26;x;\\nassert_eq!(5, x);\\nassert_eq!(5, *y);\\n\\nlet x = 5;\\nlet y = Box::new(x);\\nassert_eq!(5, x);\\nassert_eq!(5, *y);\\n\\nprintln!(\\\"{:?}\\\", y);\\n</code></pre>\\n<p>Rc is a reference counter that handles and count multiple references to a value.</p>\\n<pre><code class=\\\"language-rust\\\">let s1 = Rc::new(String::from(\\\"Pointer\\\"));\\nlet s2 = s1.clone();\\nlet s3 = s2.clone();\\nprintln!(\\\"{}, {},{}\\\", s1.contains(\\\"Point\\\"), s2, s3.contains(\\\"er\\\"));\\n</code></pre>\\n<p>RefCell allows to mutate data hold in an object whose reference is immutable.</p>\\n<pre><code class=\\\"language-rust\\\">use std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nstruct Flagger {\\n    is_true: RefCell&#x3C;bool>,\\n}\\n\\nlet flag= Flagger { is_true: Rc::new(RefCell::new(true)) };\\n// borrow returns Ref&#x3C;T>\\n// borrow_mut return RefMut&#x3C;T>\\n\\nlet reference = Rc::new(flag.is_true.clone());\\nprintln!(\\\"{:?}\\\", reference);\\n\\nlet mut mut_ref = reference.borrow_mut();\\n*mut_ref = false; // dereference first to access inside\\nprintln!(\\\"{}\\\", mut_ref);\\n</code></pre>\\n<h2>Error handling</h2>\\n<p>Errors split into two categories: </p>\\n<ul>\\n<li>recoverable errors which rely on the result type</li>\\n<li>unrecoverable errors where the panic macro is used. It terminates the current thread.</li>\\n</ul>\\n<p>Example on how to catch an error at opening a file:</p>\\n<pre><code class=\\\"language-rust\\\">let file = File::open(\\\"error.txt\\\");\\nlet file = match file {\\n    Ok(file) => file,\\n    Err(error) => match error.kind() {\\n        ErrorKind::NotFound => match File::create(\\\"error.txt\\\") {\\n            Ok(file_created) => file_created,\\n            Err(err) => panic!(\\\"Cannot create the file: {:?}\\\", err),\\n        },\\n        _ => panic!(\\\"It was some other error kind\\\"),\\n    },\\n};\\n</code></pre>\\n<p>Here is a simple way to panic and get information on error with logs:</p>\\n<pre><code class=\\\"language-rust\\\">let file = File::open(\\\"error.txt\\\").expect(\\\"Error opening the file!\\\");\\n</code></pre>\\n<p>Finally, an error that occurs in a function can be propagated upwards to the calling\\ncontext by adding a question mark to the calling statement like here:</p>\\n<pre><code class=\\\"language-rust\\\">fn open_file() -> Result&#x3C;File, Error> {\\n    let file = File::open(\\\"error.txt\\\")?;\\n    Ok(file)\\n}\\n</code></pre>\\n<h2>Unit test</h2>\\n<pre><code class=\\\"language-rust\\\">#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn it_works() {\\n        let result = 2 + 2;\\n        assert_ne!(result, 5);\\n    }\\n\\n    #[test]\\n    #[should_panic]\\n    fn it_fails(){\\n        panic!(\\\"Test failed!\\\");\\n    }\\n\\n    #[test]\\n    fn call_simple_add(){\\n        assert!(simple_add());\\n    }\\n\\n}\\n\\nfn simple_add() -> bool {\\n    if 2+2 == 4 {\\n        true\\n    } else {\\n        false\\n    }\\n}\\n</code></pre>\\n<h2>Concurrency</h2>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\n\\nfn main() {\\n    let handle = thread::spawn(move || {\\n        println!(\\\"Hello from a thread!\\\")\\n    });\\n\\n    handle.join().unwrap();\\n    println!(\\\"Hello from main\\\");\\n\\n}\\n</code></pre>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\n\\nfn main() {\\n    let v = vec![1, 2, 3];\\n    let mut thread_handles = Vec::new();\\n\\n    for e in v {\\n        // Here the move keyword is forcing the closure to take ownership:\\n        thread_handles.push(thread::spawn(move || println!(\\\"{:?}\\\", e)));\\n    }\\n\\n    println!(\\\"Main thread!\\\");\\n    \\n    for handle in thread_handles {\\n        handle.join().unwrap();\\n    }\\n}\\n</code></pre>\\n<p>Threads can communicate between each other with channels.\\nA channel has a transmitter and a receiver. A channel\\nis considered closed when either the transmitter or the\\nreceiver is dropped.</p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::mpsc; // multi producer single consumer\\n\\nfn main() {\\n    let (transmitter, receiver) = mpsc::channel();\\n    \\n    let val = String::from(\\\"Transmitting!\\\");\\n    thread::spawn(move || {\\n        transmitter.send(val).unwrap();\\n    });\\n\\n    let msg = receiver.recv().unwrap();\\n    println!(\\\"{}\\\", msg);\\n}\\n</code></pre>\\n<p>Types that implement Send are safe to pass by value to another thread. They can be moved accross threads. </p>\\n<p>Types that implement Sync are safe to pass by non mutable reference to another thread. They can be shared accross threads. </p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::Arc;\\n\\nfn main() {\\n    let rc1 = Arc::new(String::from(\\\"test\\\"));\\n    let rc2 = rc1.clone();\\n    thread::spawn(move || {\\n        rc2;\\n    });\\n}\\n</code></pre>\\n<p>Mutexes allow to manage the access of a variable by several thread.</p>\\n<pre><code class=\\\"language-rust\\\">use std::thread;\\nuse std::sync::{Arc, Mutex};\\n\\nfn main() {\\n    let counter = Arc::new(Mutex::new(0));\\n    let mut handles = vec![];\\n    \\n    for _ in 0..8 {\\n        let counter = Arc::clone(&#x26;counter);\\n        let handle = thread::spawn(move || {\\n            let mut num = counter.lock().unwrap();\\n            *num += 1;\\n        });\\n        handles.push(handle);\\n    }\\n\\n    for handle in handles {\\n        handle.join().unwrap();\\n    }\\n    \\n    println!(\\\"{}\\\", counter.lock().unwrap());\\n}\\n</code></pre>\\n<h2>Webassembly</h2>\\n<h3>Setting up of environment</h3>\\n<pre><code class=\\\"language-bash\\\">rustup update\\nrustc --version\\ncargo install cargo-generate\\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\\nnvm install 16.15.0\\n</code></pre>\\n<h3>Starting a project</h3>\\n<p>Run the command:</p>\\n<pre><code class=\\\"language-bash\\\">cargo generate --git https://github.com/rustwasm/wasm-pack-template\\n</code></pre>\\n<p>and enter a project name, e.g. wasm-game-of-life when prompted.</p>\\n<pre><code class=\\\"language-bash\\\">cd wasm-game-of-life\\nwasm-pack build\\nnpm init wasm-app www\\ncd www\\nnpm start\\n</code></pre>\",\"frontmatter\":{\"title\":\"Rust\",\"date\":\"February 06, 2022\",\"path\":\"/rust\",\"tags\":[\"rust\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h2>Formatted printing and string formatting with fmt package</h2>\\n<p>Package fmt provides 3 terminal printing functions: </p>\\n<ul>\\n<li>Printf â€” custom format</li>\\n<li>Print â€” simple print</li>\\n<li>Println â€” simple print with a newline</li>\\n</ul>\\n<p>and an F and an S variants of the above functions:</p>\\n<ul>\\n<li>F prints to a data stream: Fprintf, Fprint, Fprintln</li>\\n<li>S prints to a new string: Sprintf, Sprint, Sprintln</li>\\n</ul>\\n<p><em>verb</em>\\t\\t<em>description</em><br>\\n%v\\t\\t\\tdefault<br>\\n%t\\t\\t\\t\\\"true\\\" or \\\"false\\\"<br>\\n%c\\t\\t\\tcharacter<br>\\n%X\\t\\t\\tHex<br>\\n%U\\t\\t\\tUnicode format<br>\\n%e\\t\\t\\tScientific notation  </p>\\n<p><em>Escape Sequence</em>\\t<em>Description</em><br>\\n\\\\\\t\\t\\t\\t\\tBackslash<br>\\n'\\t\\t\\t\\t\\tSingle quote<br>\\n\\\"\\t\\t\\t\\t\\tDouble quote<br>\\n\\\\n\\t\\t\\t\\t\\tNewline<br>\\n\\\\u or \\\\U\\t\\t\\tUnicode (2byee &#x26; 4byte)<br>\\n\\\\x\\t\\t\\t\\t\\tRaw bytes (as hex digits)  </p>\\n<pre><code class=\\\"language-go\\\">fmt.Printf(\\\"%v\\\\n\\\", 8)\\nfmt.Printf(\\\"This is a \\\\\\\"Quote\\\\\\\"\\\\n\\\")\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">func surround(msg string, left, right rune) string {\\n    return fmt.Sprintf(\\\"%c%v%c\\\", left, msg, right)\\n}\\n\\nsurrounded := surround(\\\"this message\\\", '(', ')')\\nfmt.Println(surrounded)\\n</code></pre>\\n<h2>Structures</h2>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\ntype Passenger struct {\\n    name         string\\n    ticketNumber int\\n    boarded      bool\\n}\\n\\ntype Bus struct {\\n    FrontSeat passenger\\n}\\n\\nfunc main() {\\n    var (\\n        bill = Passenger{name: \\\"Bill\\\", ticketNumber: 2}\\n        ella = Passenger{name: \\\"Ella\\\", ticketNumber: 3}\\n    )\\n    fmt.Println(bill, ella)\\n    var heidi Passenger\\n    heidi.name = \\\"Heidi\\\"\\n    heidi.ticketNumber = 4\\n    fmt.Println(heidi)\\n    var vehicle = Bus{FrontSeat: ella}\\n    fmt.Println(vehicle)\\n}\\n</code></pre>\\n<h2>Arrays</h2>\\n<pre><code class=\\\"language-go\\\">Go arrays have fixed size. \\n</code></pre>\\n<h2>Slices</h2>\\n<p>Slices are companion types that work with arrays.\\nThey enable a \\\"view\\\" into an array.\\nViews are dynamic and not fixed in size.\\nFunctions can accept a clice as a function parameter.\\nAny array can be operated upon via slice.</p>\\n<pre><code class=\\\"language-go\\\">mySlice := []int{1, 2, 3}\\nitem1 := mySlice[0]\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">numbers := [...]int{1, 2, 3, 4}\\nslice1 := numbers[:]\\nslice2 := numbers[1:]\\nslice3 := numbers[:1]\\nslice4 := numbers[:2]\\nslice5 := numbers[1:3]\\n</code></pre>\\n<p>The <code>append()</code> function can add additional elements:</p>\\n<pre><code class=\\\"language-go\\\">numbers := [...]int{1, 2, 3, 4}\\nnumbers = append(numbers, 4, 5, 6)\\n</code></pre>\\n<p>3 dots can be used to extend a slice with another slice:</p>\\n<pre><code class=\\\"language-go\\\">part1 := []int{1, 2, 3}\\npart2 := []int{4, 5, 6}\\ncombined := append(part1, part2...)\\n</code></pre>\\n<p>Slices can be preallocated with specific capacities using the make function:</p>\\n<pre><code class=\\\"language-go\\\">slice := make([]int, 10)\\n</code></pre>\\n<p>This saves computation time.</p>\\n<p>The len() function returns the length of any slice;</p>\\n<pre><code class=\\\"language-go\\\">for i:=0; i &#x3C; len(slice); i++ {\\n    // ...\\n}\\n</code></pre>\\n<p>Slices can be multidimensional:</p>\\n<pre><code class=\\\"language-go\\\">board := [][] string {\\n    []string{\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n    {\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n    {\\\"_\\\", \\\"_\\\", \\\"_\\\"},\\n}\\nboard[0][0] = \\\"X\\\"\\nboard[0][0] = \\\"O\\\"\\n</code></pre>\\n<h2>Ranges</h2>\\n<p>The range keyword creates an iterator.</p>\\n<pre><code class=\\\"language-go\\\">slice := []string{\\\"Hello\\\", \\\"world\\\", \\\"!\\\"}\\nfor i, element := range slice {\\n    fmt.Println(i, element, \\\":\\\")\\n    for _, ch := range element {\\n        fmt.Printf(\\\"  %q\\\\n\\\", ch)\\n    }\\n}\\n</code></pre>\\n<h2>Maps</h2>\\n<pre><code class=\\\"language-go\\\">myMap1 := make(map[string]int)\\n\\nmyMap2 := map[string]int{\\n    \\\"item 1\\\": 1,\\n    \\\"item 2\\\": 2,\\n    \\\"item 3\\\": 3,\\n}\\n\\nmyMap1[\\\"favorite number\\\"] = 5\\nmissing := myMap1[\\\"age\\\"] // default value\\n\\ndelete (myMap1, \\\"favorite number\\\")\\n\\nprice, found := myMap1[\\\"price\\\"]\\nif !found {\\n    fmt.Println(\\\"price not found\\\")\\n    return\\n}\\n</code></pre>\\n<p>Just like slices, maps can be iterated through using the range keyword:</p>\\n<pre><code class=\\\"language-go\\\">for key, value := range myMap2 {\\n    // ...\\n}\\n</code></pre>\\n<h2>Pointers</h2>\\n<p>An asterisk (*) used with a type indicates the value is a pointer.\\nAn ampersand (&#x26;) creates a pointer from a variable.</p>\\n<pre><code class=\\\"language-go\\\">value := 10\\nvar valuePtr *int // this declaration is often skipped\\nvaluePtr = &#x26;value // value address\\n</code></pre>\\n<p>An asterisk (*) when used with a pointer will dereference the pointer</p>\\n<pre><code class=\\\"language-go\\\">func increment(x *int) {\\n    *x += 1\\n}\\n\\ni := 1\\nincrement(&#x26;i)\\n</code></pre>\\n<p>Example: </p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\ntype SecurityTag struct {\\n    state bool\\n}\\n\\nfunc activate(tag *SecurityTag) {\\n    tag.state = true\\n}\\n\\nfunc deactivate(tag *SecurityTag) {\\n    tag.state = false\\n}\\n\\nfunc checkout(slice []*SecurityTag) {\\n    for _, tag := range slice {\\n        deactivate(tag)\\n    }\\n}\\n\\nfunc printSlice(slice []*SecurityTag) {\\n    fmt.Printf(\\\"%t\\\\n %t\\\\n %t\\\\n %t\\\\n\\\", slice[0].state, slice[1].state, slice[2].state, slice[3].state)\\n}\\n\\nfunc main() {\\n    item1 := SecurityTag{state: true}\\n    item2 := SecurityTag{state: true}\\n    item3 := SecurityTag{state: true}\\n    item4 := SecurityTag{state: true}\\n\\n    items := []*SecurityTag{&#x26;item1, &#x26;item2, &#x26;item3, &#x26;item4}\\n    printSlice(items)\\n\\n    deactivate(&#x26;item1)\\n    printSlice(items)\\n\\n    checkout(items)\\n    printSlice(items)\\n\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” receiver functions</h2>\\n<p>Receiver functions privide the dot notation for structs. This allows to\\ncreate more convenient APIs.</p>\\n<pre><code class=\\\"language-go\\\">type Coordinate struct {\\n    X, Y int\\n}\\n\\nfunc (coord *Coordinate) shiftBy(x, y int) {\\n    coord.X += x\\n    coord.Y += y\\n}\\n\\ncoord := Coordinate{5, 5}\\ncoord.shiftBy(1, 1) // (6, 6)\\n</code></pre>\\n<h2>Idiomatic Go â€” iota</h2>\\n<p>The iota keyword can be used to assign integers to constants.\\nThe two following snippets define and initialize constant\\nOnline to 0, Offline to 1, Maintenance to 2 and Retired to 3.</p>\\n<pre><code class=\\\"language-go\\\">// Short form\\nconst (\\n    Online = iota\\n    Offline\\n    Maintenance\\n    Retired\\n)\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">// Long form:\\nconst (\\n    Online = iota\\n    Offline = iota\\n    Maintenance = iota\\n    Retired = iota\\n)\\n</code></pre>\\n<p>Go allows to skip values as follows:</p>\\n<pre><code class=\\\"language-go\\\">const (\\n    s0 = iota   // 0\\n    -           // 1\\n    -           // 2\\n    s3          // 3\\n    s4          // 4\\n)\\n</code></pre>\\n<p>It is possible to start at a different value:</p>\\n<pre><code class=\\\"language-go\\\">const (\\n    i3 = iota + 3   // 3\\n    i4              // 4\\n    i5              // 5\\n)\\n</code></pre>\\n<h2>Idiomatic Go â€” variadics</h2>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"fmt\\\"\\n\\nfunc sum(nums ...int) int {\\n    sum := 0\\n    for _, n := range nums {\\n        sum += n\\n    }\\n    return sum\\n}\\n\\nfunc main() {\\n    a := []int{1, 2, 3}\\n    b := []int{4, 5, 6}\\n\\n    all := append(a, b...)\\n\\n    answer := sum(all...)\\n    fmt.Println(answer)\\n\\n    answer := sum(1, 2, 3, 4, 5, 6)\\n    fmt.Println(answer)\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” init function</h2>\\n<p>Each package can have it's own init() function. The init function\\nof each will run a single time even when the package is imported\\nseveral times.</p>\\n<p>For instance an init function can initialize an object in file init.go:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nvar EmailExpr *regexp.Regexp\\n\\nfunc init() {\\n    compiled, ok := regexp.Compile(`.+@.+\\\\..+`)\\n    if ok != nil {\\n        panic(\\\"failed to compile regular expression\\\")\\n    }\\n    EmailExpr = compiled\\n    fmt.Println(\\\"regular expression compiled successfully\\\")\\n}\\n</code></pre>\\n<p>The latter object can be used in the main.go like this:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nvar EmailExpr *regexp.Regexp\\n\\nfunc IsValidEmail(addr string) bool {\\n    return EmailExpr.Match([]byte(addr))\\n}\\n\\nfunc main() {\\n    fmt.Println(isValidEmail(\\\"invalid@example\\\"))\\n}\\n</code></pre>\\n<h2>Idiomatic Go â€” testing</h2>\\n<p>A unit test for the above main function can be coded in a file\\ncalled <code>main_test.go</code>:</p>\\n<pre><code class=\\\"language-go\\\">package main\\n\\nimport \\\"testing\\\"\\n\\nfunc TestIsValidEmail(t *testing.T) {\\n    data := \\\"email@example.com\\\"\\n    if !IsValidEmail(data) {\\n        t.Errorf(\\\"IsValidEmail(%v)=false, want true\\\", data)\\n    }\\n}\\n</code></pre>\\n<p>Tests can be executed with</p>\\n<pre><code class=\\\"language-bash\\\">go test\\n</code></pre>\\n<p>To execute tests in a specific file execute for instance: </p>\\n<pre><code class=\\\"language-bash\\\">go test -v ./foo/foo_test.go\\n</code></pre>\\n<p>Some functions available in the test package:</p>\\n<ul>\\n<li><code>Fail()</code>: mark the test as failed</li>\\n<li><code>Errorf(string)</code>: fail &#x26; add a message</li>\\n<li><code>FailNow()</code>: mark the test as failed, abort current test</li>\\n<li><code>Fatalf(string)</code>: fail, abort and add a message</li>\\n<li><code>Logf()</code>: equivalent to Printf, but only when test fails</li>\\n</ul>\\n<p>A <a href=\\\"https://yourbasic.org/golang/table-driven-unit-test/\\\">test table</a> can\\nbe nicely coded to test a function with more than one set of data.</p>\\n<h2>Function literals</h2>\\n<p>Function literals also known as anonymous function\\nare functions within a function. They can encapsulate data.</p>\\n<pre><code class=\\\"language-go\\\">func helloWorld() {\\n    fmt.Printf(\\\"Hello, \\\");\\n    world := func() {\\n        fmt.Printf(\\\"World!\\\\n\\\")\\n    }\\n    world()\\n    world()\\n    world()\\n}\\n</code></pre>\\n<p>A function literal can be passed as a parameter to a function: </p>\\n<pre><code class=\\\"language-go\\\">func customMsg(fn func(m string), msg string) {\\n    msg = strings.ToUpper(msg)\\n    fn(msg)\\n}\\n\\nfunc surround() func(msg string) {\\n    return func(msg string) {\\n        fmt.Printf(\\\"%.*s\\\\n\\\", len(msg), \\\"------------\\\"))\\n        fmt.Println(msg)\\n        fmt.Printf(\\\"%.*s\\\\n\\\", len(msg), \\\"------------\\\"))\\n    }\\n}\\n\\ncustomMsg(surround(), \\\"hello\\\")\\n</code></pre>\\n<p>Closures are function literals that access variables\\ndefined outside of their scope.</p>\\n<p>A type alias can be defined for a literal function so\\nthat is is simple to pass it as a parameter to a function: </p>\\n<pre><code class=\\\"language-go\\\">type DiscountFunc func(subTotal float64) float64\\n\\nfunc calculatePrice(\\n        subtotal float64,\\n        discountFn DiscountFunc\\n    ) float64 {\\n        return subTotal - (subTotal * discountFn(subTotal))\\n}\\n</code></pre>\\n<h2>Interfaces</h2>\\n<p>Interfaces allow specifying the behavior of a type.</p>\\n<pre><code class=\\\"language-go\\\">type MyInterface interface {\\n    Function1()\\n    Function2(x int) int\\n}\\n\\ntype MyType int\\nfunc (m MyType) Function1() {}\\nfunc (m MyType) Function2(x int) int {\\n    return x + x\\n}\\n\\nfunc execute(i MyInterface) {\\n    i.Function1()\\n}\\n</code></pre>\\n<p>When a type has all receiver functions required by the\\ninterface, then it is considered implemented.</p>\\n<h4>Standard Library use case: errors</h4>\\n<p>The Error() string function of the errors interface\\nfrom the standard library. The errors.New function returns\\nan Error.</p>\\n<pre><code class=\\\"language-go\\\">import \\\"errors\\\"\\n\\nfunc divide(lhs, rhs int) (int, error) {\\n    if rhs == 0 {\\n        return 0, errors.New(\\\"cannot divide by zero\\\")\\n    } else {\\n        return rhs / lhs, nil\\n    }\\n}\\n</code></pre>\\n<p>Here is the error interface:</p>\\n<pre><code class=\\\"language-go\\\">type error interface {\\n    Error() string\\n}\\n</code></pre>\\n<p>Always implement error as a receiver function:</p>\\n<pre><code class=\\\"language-go\\\">type DivError struct {\\n    a, b int\\n}\\n\\nfunc (d *DivError) Error() string {\\n    return fmt.Sprintf(\\\"Cannot divide by zero: %d / %d\\\", d.a, d.b)\\n}\\n\\nfunc div(a, b int) (int, error) {\\n    if b == 0 {\\n        return 0, &#x26;DivError{a, b}\\n    } else {\\n        return a / b, nil\\n    }\\n}\\n\\nanswer1, err := div(9, 0)\\n\\nif err != nil {\\n    fmt.Println(err)\\n    return\\n}\\n\\nfmt.Println(\\\"The answer is: \\\", answer1)\\n</code></pre>\\n<p>Additional features from errors:</p>\\n<ul>\\n<li>use errors.As() to retrieve and error</li>\\n<li>use errors.Is() to check the error type</li>\\n</ul>\\n<h4>Standard Library use case: Reader &#x26; Writer</h4>\\n<p>Reader &#x26; Writer are interfaces that allow reading from and\\nwriting to I/O sources like: network sockets, files, arbitrary arrays.</p>\\n<pre><code class=\\\"language-go\\\">type Reader interface {\\n    Read(p []byte) (n int, err error)\\n}\\n\\ntype Writer interface {\\n    Write(p []byte) (n int, err error)\\n}\\n</code></pre>\\n<p>Each call to Read() will fill the provided p buffer.\\nThe number of bytes read will be returned as n.\\nWhen all bytes have been read, err will be io.EOF.</p>\\n<p>Using Reader directly requires manually populating a buffer.\\nThe bufio stdlib package provides auto-buffered reads. In practice\\nit is more usual to work with the bufio package instead of the\\nlow level Reader directly as shown comparing the two following approaches:</p>\\n<pre><code class=\\\"language-go\\\">reader := strings.NewReader(\\\"SAMPLE\\\")\\n\\nvar newString strings.Builder\\nbuffer := make([]byte, 4)\\nfor {\\n    numBytes, err := reader.Read(buffer)\\n    chunk := buffer[:numBytes]\\n    newString.Write(chunk)\\n    fmt.Printf(\\\"Read %v bytes: %c\\\\n\\\", numBytes, chunk)\\n    if err == io.EOF {\\n        break\\n    }\\n}\\nfmt.Printf(\\\"%v\\\\n\\\", newString.String())\\n</code></pre>\\n<pre><code class=\\\"language-go\\\">source := strings.NewReader(\\\"SAMPLE\\\")\\nbuffered := bufio.NewReader(source)\\n// can also user buffered.ReadBytes here:\\nnewString, err := buffered.ReadString('\\\\n')\\nif err == io.EOF {\\n    fmt.Println(newString)\\n} else {\\n    fmt.Println(\\\"something went wrong...\\\")\\n}\\n</code></pre>\\n<p>The bufio.Scanner provides more features.\\nIt can automatically read and delimit inputs.</p>\\n<pre><code class=\\\"language-go\\\">// read lines from standard input\\nscanner := bufio.NewScanner(os.Stdin)\\nlines := make([]string, 0, 5)\\nfor scanner.Scan() {\\n    lines = append(lines, scanner.Text())\\n}\\nif scanner.Err() != nil {\\n    fmt.Println(scanner.Err())\\n}\\nfmt.Printf(\\\"Line count: %v\\\\n\\\", len(lines))\\nfor _, line := range lines {\\n    fmt.Printf(\\\"Line: %v\\\\n\\\", line)\\n}\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">printf \\\"these\\\\nare\\\\nsome\\\\nwords\\\" | go run ./scannercode.go\\n</code></pre>\\n<p>Writer is symmetrical with Reader:</p>\\n<pre><code class=\\\"language-go\\\">buffer := bytes.NewBufferString(\\\"\\\")\\nnumBytes, err := buffer.WriteString(\\\"SAMPLE\\\")\\nif err != nil {\\n    fmt.Println(err)\\n} else {\\n    fmt.Printf(\\\"Wrote %v bytes: %c\\\\n\\\", numBytes, buffer)\\n}\\n</code></pre>\\n<h4>Language use case: Type Embedding</h4>\\n<p>Embedded interfaces allow to \\\"embed\\\" an interface into another interface.</p>\\n<pre><code class=\\\"language-go\\\">type Whisperer interface {\\n    Whisper() string\\n}\\n\\n\\ntype Yeller interface {\\n    Yeller() string\\n}\\n\\ntype Talker interface {\\n    Whisperer\\n    Yeller\\n}\\n\\nfunc talk(t Talker) {\\n    fmt.Println(t.Yell())\\n    fmt.Println(t.Whisper())\\n} \\n</code></pre>\\n<p>Embedded structs allow to \\\"embed\\\" a struct into another struct.\\nThe struct will have access to all receiver functions and data\\nof the embedded struct at the top level. This is called\\nfield and method promotion.</p>\\n<pre><code class=\\\"language-go\\\">type Account struct {\\n    accountId int\\n    balance int\\n    name string\\n}\\n\\ntype ManagerAccount struct {\\n    Account\\n}\\n\\nmgrAcct := ManagerAccount{Account{2, 30, \\\"Cassandra\\\"}}\\n</code></pre>\\n<h4>Language use case: Generics</h4>\\n<p>Generics are defined using interfaces, called constraints.\\nFunction parameters and return types are constrained to a\\nspecific set of interfaces:</p>\\n<pre><code class=\\\"language-go\\\">func name[T contraint, U constraintA | constraintB](a T, b U) T {\\n    // ...\\n}\\n</code></pre>\\n<p>Example: </p>\\n<pre><code class=\\\"language-go\\\">func IsEqual[T comparable](a, b T) bool {\\n    return a == b\\n}\\n</code></pre>\\n<p>Tilde can be used to specify that approximation on a type is allowed:</p>\\n<pre><code class=\\\"language-go\\\">type Integer32 interface {\\n    ~int32 | ~uint32\\n}\\n\\ntype MyInt int32\\n</code></pre>\\n<h2>Using defer</h2>\\n<pre><code class=\\\"language-go\\\">func one() {\\n    fmt.Println(\\\"1\\\")\\n}\\n\\nfunc two() {\\n    fmt.Println(\\\"2\\\")\\n}\\n\\nfunc sample() {\\n    fmt.Println(\\\"Begin\\\")\\n    defer one()\\n    defer two()\\n    fmt.Println(\\\"End\\\")\\n}\\n</code></pre>\\n<h2>Concurrency â€” goroutines</h2>\\n<pre><code class=\\\"language-go\\\">func count(amount int) {\\n    for i := 1; i &#x3C;= amount; i++ {\\n        time.Sleep(100 * time.Millisecond)\\n        fmt.Println(i)\\n    }\\n}\\n\\nfunc main() {\\n    go count(5)\\n    fmt.Println(\\\"wait for goroutine\\\")\\n    time.Sleep(1000 * time.Millisescond)\\n    fmt.Println(\\\"end program\\\")\\n}\\n</code></pre>\\n<p>Goroutines allow functions and closures to un concurrently.\\nUse the go keyword to create a new goroutine.  </p>\\n<p>The function that starts a goroutine will not wait for it to finish.\\nBoth the the calling function and goroutine will run to completion.  </p>\\n<p>Closure captures are shared among all goroutines, making it easy\\nto parallelize code.</p>\\n<h2>Concurrency â€” channels</h2>\\n<p>Channels are one-way communication pipes. They have\\na send/write end and a receive/read end.\\nThe ends can be duplicated across goroutines.\\nBidirectional communication can be accomplished by using\\nmore channels.  </p>\\n<p>Buffered channels are non-blocking, unbuffered channels\\nwill block.</p>\\n<pre><code class=\\\"language-go\\\">channel := make(chan int)\\n\\n// Send to channel\\ngo func() { channel &#x3C;- 1 }()\\ngo func() { channel &#x3C;- 2 }()\\ngo func() { channel &#x3C;- 3 }()\\n\\n// Receive from channel\\nfirst := &#x3C;-channel\\nsecond := &#x3C;-channel\\nthird := &#x3C;-channel\\n\\nfmt.Println(first, second, third)\\n</code></pre>\\n<p>The time package can be combined with select\\nto create timeouts:</p>\\n<pre><code class=\\\"language-go\\\">one := make(chan int)\\ntwo := make(chan int)\\n\\nfor {\\n    select {\\n        case o := &#x3C;-one:\\n            fmt.Println(\\\"one:\\\", o)\\n        case t := &#x3C;-two:\\n            fmt.Println(\\\"two:\\\", t)\\n        case o := &#x3C;-time.After(300 * time.Millisecond):\\n            fmt.Println(\\\"timed out\\\")\\n            return\\n    }\\n}\\n</code></pre>\\n<h2>Concurrency â€” synchronization</h2>\\n<p>Managing data accross multiple goroutines\\ncan become problematic and hard to debug because:  </p>\\n<ul>\\n<li>multiple goroutines can change the same data leading\\nto unpredictable results  </li>\\n<li>using channels to communicate is not always ideal  </li>\\n</ul>\\n<p>Synchronization solves this issue:  </p>\\n<ul>\\n<li>enables waiting for goroutines to finish  </li>\\n<li>prevents multiple goroutines from modifying data\\nsimultaneously  </li>\\n</ul>\\n<p>A mutex provides a way to lock and unlock data. It\\nallows to work with multiple goroutines.</p>\\n<pre><code class=\\\"language-go\\\">import \\\"sync\\\"\\n\\ntype SyncedData struct {\\n    inner map[string] int\\n    mutex sync.Mutex\\n}\\n\\nfunc (d *SyncedData) Insert(k string, v int) {\\n    d.mutex.Lock()\\n    defer d.mutex.Unlock()\\n    d.inner[k] = v\\n}\\n\\nfunc (d *SyncedData) Get(k string) int {\\n    d.mutex.Lock()\\n    defer d.mutex.Unlock()\\n    return d.inner[k]\\n}\\n\\nfunc main() {\\n    data := SyncedData{ inner: make(map[string]int) }\\n    data.Insert(\\\"sample\\\", 5)\\n    data.Insert(\\\"test\\\", 2)\\n    fmt.Println(data.Get(\\\"sample\\\"))\\n    fmt.Println(data.Get(\\\"test\\\"))\\n}\\n</code></pre>\\n<p>Wait groups enable an application to wait for goroutines\\nto finish. They operate by incrementing a counter whenever\\na goroutine is added, and decrementing when it finishes.\\nWaiting on the group will block execution until the\\ncounter is 0.</p>\\n<pre><code class=\\\"language-go\\\">var wg sync.WaitGroup\\nsum := 0\\nfor i := 0; i &#x3C; 20; i++ {\\n    wg.Add(1)\\n    value := i\\n    go func() {\\n        defer wg.Done()\\n        sum += value\\n    }()\\n}\\nwg.Wait()\\nfmt.Println(\\\"sum = \\\", sum)\\n</code></pre>\\n<h2>Cross compiling and cgo</h2>\\n<p>When not cross compiling, cgo is enabled by default. This is\\nthe case when executing a command like:</p>\\n<pre><code class=\\\"language-sh\\\">go build -o main main.go\\n</code></pre>\\n<p>Links pertaining to the compiled file can be displayed with:</p>\\n<pre><code class=\\\"language-sh\\\">ldd main\\n</code></pre>\\n<p>Compilation without cgo can be performed with:</p>\\n<pre><code class=\\\"language-sh\\\">CGO_ENABLED=0 go build -o main-nocgo main.go\\n</code></pre>\\n<p>Cross compilation for a given os/architecture combination say darwin/amd64 can be done\\nwith:</p>\\n<pre><code class=\\\"language-sh\\\">GOOS=darwin ARCH=amd64 go build -o main-darwin64 main.go\\n</code></pre>\\n<p>Available combinations can be displayed with:</p>\\n<pre><code class=\\\"language-sh\\\">go tool dist list\\n</code></pre>\",\"id\":\"C:/Users/nicolas.peron/github.com/nperon/workshop/src/pages/2022-06-14-go/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-06-14T14:24:43.180Z\",\"path\":\"/go\",\"title\":\"Go\",\"excerpt\":\"Go\",\"tags\":[\"go\"]}},\"next\":{\"html\":\"<p>The following few steps can be taken as a quick start to Argo CD\\nthat can be done with a local cluster, say minikube. </p>\\n<h2>Starting argocd non HA with cluster privilege</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n</code></pre>\\n<h2>Displaying argocd initial admin secret</h2>\\n<pre><code class=\\\"language-zsh\\\">ENCODED=$(kubectl -n argocd get secret argocd-initial-admin-secret -o yaml | yq .data.password)\\necho $ENCODED\\necho $ENCODED | base64 --decode\\n</code></pre>\\n<h2>Exposing argocd server with a port forward argocd server pod</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl port-forward svc/argocd-server -n argocd 8080:443\\n</code></pre>\\n<p>Open browser at <a href=\\\"https://localhost:8080\\\">https://localhost:8080</a></p>\\n<h2>Using ArgoCD CLI</h2>\\n<p>CLI allows to manage everything: applications, repos, clusters, tasks, projects...</p>\\n<pre><code class=\\\"language-zsh\\\">argocd login localhost:8080\\nargocd cluster list\\n</code></pre>\\n<h2>Applications</h2>\\n<p>Given the following yaml content in a file called <code>application.yml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>run the following commands:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application.yml\\n</code></pre>\\n<p>And then verify the application was created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get application -n argocd\\n</code></pre>\\n<p>Other app based on helm can be started the same way:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_helm_options.yml\\n</code></pre>\\n<p>where <code>application_helm_options.yml</code> has a content like:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: helm-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: helm-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: helm-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    helm:\\n      releaseName: my-release\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Finally, an application loaded recursively from\\na local directory can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_subdirectories_options.yml\\n</code></pre>\\n<p>with a file <code>application_subdirectories_options.yml</code>\\nwith a content:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: directory-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: directory-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Here are ArgoCD options which can be adjusted with kustomize:</p>\\n<ul>\\n<li>Name prefix: appended to resources</li>\\n<li>Name suffix: appended to resources</li>\\n<li>Images: to override images</li>\\n<li>Common labels: set labels on all resources</li>\\n<li>Common annotations: set annotations on all resources</li>\\n<li>Version: explicitly set kustomize version</li>\\n</ul>\\n<p>The manifest below called for instance <code>application_kustomize.yaml</code> is an example of an kustomize argocd application. Two options are adjusted with kustomize: namePrefix\\nand a commonLabel with a key of app and a value of demo. </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: kustomize-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: kustomize-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: kustomize-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    kustomize:\\n      namePrefix: staging-\\n      commonLabels:\\n        app: demo\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Application can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_kustomize.yml\\n</code></pre>\\n<p>Note that Argo CD automatically detects that\\nit is a Kustomize application.</p>\\n<h2>Projects</h2>\\n<p>Display info on by default project:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>Now a project can be created by running </p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f ./project.yaml\\n</code></pre>\\n<p>with a file called project.yaml: </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: demo-project\\n  namespace: argocd\\nspec:\\n  description: Demo Project\\n  sourceRepos:\\n  - '*'\\n\\n  destinations:\\n  - namespace: '*'\\n    server: '*'\\n\\n  clusterResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n\\n  namespaceResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n</code></pre>\\n<p>Display info on projects again with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>An application can be defined to start in the project thus created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f './application.yml'\\n</code></pre>\\n<p>with the following content for application.yml:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook-demo-project\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook-demo-project\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: demo-project\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<h2>Sync</h2>\\n<p>Automated syncing can be enabled by declaring a syncPolicy in the\\nmanifest of the application. Or by adding a <code>sync-policy automated</code>\\nflag to a cli <code>argocd app create</code> command. There is also a\\nSYNC POLICY setting which can be set to Automatic in the Web UI.</p>\\n<p>Example of an application manifest:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: auto-sync-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: auto-sync-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    automated: {}\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<ul>\\n<li>\\n<p>Additional features: </p>\\n<ul>\\n<li>automated pruning</li>\\n<li>self healing</li>\\n</ul>\\n</li>\\n<li>\\n<p>Sync Options with at the resource level with annotations or at the\\napplication level with syncOptions (in syncPolicy):</p>\\n<ul>\\n<li>Prune = false</li>\\n<li>Validate = false</li>\\n</ul>\\n</li>\\n<li>\\n<p>Selective syncing at the application level only with syncOptions:\\nApplyOutOfSyncOnly=true</p>\\n</li>\\n<li>\\n<p>Argo waves with PruneLast=true at application or resource level.</p>\\n</li>\\n<li>\\n<p>Replacing resources: by default Argo CD uses <code>kubectl apply</code> to\\ndeploy resources changes\\nIn some cases, you need to replace/recreate the resources.\\nArgoCD can do this by using replace=true. It can be done at application level\\nwith a Replace of true in syncOptions. It can be also done at resource level\\nwith an annotation like <code>argocd.argoproj.io/sync-options: Replace=true</code></p>\\n</li>\\n<li>\\n<p>sync can be configured to fail if resource is found in other applications\\nby using FailOnSharedResource=true</p>\\n</li>\\n</ul>\",\"id\":\"C:/Users/nicolas.peron/github.com/nperon/workshop/src/pages/2022-08-14-argocd/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-08-14T22:51:00.823Z\",\"path\":\"/argocd\",\"title\":\"Argo CD\",\"excerpt\":\"\",\"tags\":[\"continuous delivery\",\"cloud\",\"devops\",\"gitops\",\"kubernetes\",\"kustomize\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/rust.json\n// module id = 470\n// module chunks = 101400775151803"],"sourceRoot":""}