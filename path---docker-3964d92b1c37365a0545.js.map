{"version":3,"sources":["webpack:///path---docker-3964d92b1c37365a0545.js","webpack:///./.cache/json/docker.json"],"names":["webpackJsonp","381","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","prev","id","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,k5DAAAC,aAAk7DC,MAAA,iBAAAC,KAAA,iBAAAC,KAAA,UAAAC,MAAA,+BAAAC,QAAA,yBAA2IC,aAAgBC,MAAQR,KAAA,qMAAAS,GAAA,4GAAAR,aAA8UE,KAAA,2BAAAC,KAAA,SAAAF,MAAA,QAAAI,QAAA,yBAAAD,MAAA,6BAAyIK,MAASV,KAAA,soKAA22KS,GAAA,0GAAAR,aAAgJE,KAAA,2BAAAC,KAAA,iBAAAF,MAAA,+BAAAI,QAAA,GAAAD,MAAA","file":"path---docker-3964d92b1c37365a0545.js","sourcesContent":["webpackJsonp([174890689291889],{\n\n/***/ 381:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Create a container with a mongo database and connect to it</h3>\\n<p>Start with displaying all currently running containers:</p>\\n<pre><code class=\\\"language-bash\\\">docker ps\\n</code></pre>\\n<p>Then create locally the container associated with the mongo docker image:</p>\\n<pre><code class=\\\"language-bash\\\">docker run -p 27017:27017 -d mongo\\n</code></pre>\\n<p>Executing another time <code>docker ps</code> results in information on the created container like the following being displayed:</p>\\n<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES\\n2c6a61aba41b        mongo               \\\"docker-entrypoint.s…\\\"   3 minutes ago       Up 3 minutes        0.0.0.0:27017->27017/tcp   clever_dubinsky\\n</code></pre>\\n<p>Connection to the database at url localhost:27017 can be opened using for instance the robo-3t nosql database editor.\\nFinally, the container when not needed anymore can be stopped with:</p>\\n<pre><code>docker stop 2c6a61aba41b\\n</code></pre>\\n<h3>Create a container with a PostgreSQL database given the database name and the user credentials</h3>\\n<p>Let us assume we need to connect to a database called course_data in a PostgreSQL SGBD with the following credentials: the user is postgres and the password is password. The command line to launch a docker container with such a database is:</p>\\n<pre><code class=\\\"language-bash\\\">docker run --name postgresdb -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=password -e POSTGRES_DB=course_data -d -p 5432:5432 postgres\\n</code></pre>\\n<p>Terminal access to the database prompt is obtained by first accessing the container shell:</p>\\n<pre><code class=\\\"language-bash\\\">docker container exec -it postgresdb bash\\n</code></pre>\\n<p>The postgre prompt of user 'postgres' may then be accessed with:</p>\\n<pre><code class=\\\"language-bash\\\">psql course_data postgres\\n</code></pre>\",\"frontmatter\":{\"title\":\"Docker Recipes\",\"date\":\"March 31, 2020\",\"path\":\"/docker\",\"tags\":[\"docker\",\"container\",\"devops\"],\"excerpt\":\"Some Docker Recipes\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h3>General documentation</h3>\\n<h3>Bootstrap</h3>\\n<p><a href=\\\"https://loiane.com/2017/08/how-to-add-bootstrap-to-an-angular-cli-project/\\\">How to Add Bootstrap to an Angular CLI project</a></p>\",\"id\":\"/home/nicolas/Documents/workshop/src/pages/2019-03-05-styling/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2019-03-05T22:35:12.235Z\",\"path\":\"/style\",\"title\":\"Style\",\"excerpt\":\"Documentation on style\",\"tags\":[\"style\",\"css\",\"bootstrap\"]}},\"next\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"id\":\"/home/nicolas/Documents/workshop/src/pages/2020-08-29-ELK-2/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-08-29T22:47:32.235Z\",\"path\":\"/elk-searching\",\"title\":\"Searching with Elasticsearch\",\"excerpt\":\"\",\"tags\":[\"Elastic Search\",\"searching\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---docker-3964d92b1c37365a0545.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<h3>Create a container with a mongo database and connect to it</h3>\\n<p>Start with displaying all currently running containers:</p>\\n<pre><code class=\\\"language-bash\\\">docker ps\\n</code></pre>\\n<p>Then create locally the container associated with the mongo docker image:</p>\\n<pre><code class=\\\"language-bash\\\">docker run -p 27017:27017 -d mongo\\n</code></pre>\\n<p>Executing another time <code>docker ps</code> results in information on the created container like the following being displayed:</p>\\n<pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES\\n2c6a61aba41b        mongo               \\\"docker-entrypoint.s…\\\"   3 minutes ago       Up 3 minutes        0.0.0.0:27017->27017/tcp   clever_dubinsky\\n</code></pre>\\n<p>Connection to the database at url localhost:27017 can be opened using for instance the robo-3t nosql database editor.\\nFinally, the container when not needed anymore can be stopped with:</p>\\n<pre><code>docker stop 2c6a61aba41b\\n</code></pre>\\n<h3>Create a container with a PostgreSQL database given the database name and the user credentials</h3>\\n<p>Let us assume we need to connect to a database called course_data in a PostgreSQL SGBD with the following credentials: the user is postgres and the password is password. The command line to launch a docker container with such a database is:</p>\\n<pre><code class=\\\"language-bash\\\">docker run --name postgresdb -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=password -e POSTGRES_DB=course_data -d -p 5432:5432 postgres\\n</code></pre>\\n<p>Terminal access to the database prompt is obtained by first accessing the container shell:</p>\\n<pre><code class=\\\"language-bash\\\">docker container exec -it postgresdb bash\\n</code></pre>\\n<p>The postgre prompt of user 'postgres' may then be accessed with:</p>\\n<pre><code class=\\\"language-bash\\\">psql course_data postgres\\n</code></pre>\",\"frontmatter\":{\"title\":\"Docker Recipes\",\"date\":\"March 31, 2020\",\"path\":\"/docker\",\"tags\":[\"docker\",\"container\",\"devops\"],\"excerpt\":\"Some Docker Recipes\"}}},\"pathContext\":{\"prev\":{\"html\":\"<h3>General documentation</h3>\\n<h3>Bootstrap</h3>\\n<p><a href=\\\"https://loiane.com/2017/08/how-to-add-bootstrap-to-an-angular-cli-project/\\\">How to Add Bootstrap to an Angular CLI project</a></p>\",\"id\":\"/home/nicolas/Documents/workshop/src/pages/2019-03-05-styling/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2019-03-05T22:35:12.235Z\",\"path\":\"/style\",\"title\":\"Style\",\"excerpt\":\"Documentation on style\",\"tags\":[\"style\",\"css\",\"bootstrap\"]}},\"next\":{\"html\":\"<h3>Query Lite alias URI Search</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=title:star&#x26;pretty\\\"\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET \\\"127.0.0.1:9200/movies/_search?q=+year>2010+title:trek&#x26;pretty\\\"\\n</code></pre>\\n<h3>JSON Search</h3>\\n<p>Some types of filters</p>\\n<p>Term: filter by exact values\\n{\\\"term\\\": {\\\"year\\\": 2014}}</p>\\n<p>Terms: match if any exact values in a list match\\n{\\\"terms\\\": {\\\"genre\\\": [\\\"Sci-Fi\\\", \\\"Adventure\\\"] } }</p>\\n<p>Range: find numbers or dates in a given range (gt, gte, lt, lte)\\n{\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}</p>\\n<p>Exists: find documents where a field exists\\n{\\\"exists\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Missing: find documents where a field is missing\\n{\\\"missing\\\": {\\\"field\\\": \\\"tags\\\"}}</p>\\n<p>Bool: combine filters with boolean logic (must, must_not, should)</p>\\n<p>Some types of Queries</p>\\n<p>Match<em>all: returns all documents and is the default. Normally used with a filter.\\n{\\\"match</em>all\\\": {}}</p>\\n<p>Match: searches analyzed results, such as full text search.\\n{\\\"match\\\": {\\\"title\\\": \\\"star\\\"}}</p>\\n<p>Multi-match: run the same query on multiple fields.\\n{\\\"multi-match\\\": {\\\"query\\\":\\\"star\\\", \\\"fields\\\": [\\\"title\\\", \\\"synopsis\\\"]}}</p>\\n<p>Bool: works like a bool filter, but results are scored by relevance.</p>\\n<p>Syntax:\\nQueries are wrapped in a \\\"query\\\": { } block.\\nFilters are wrapped in a \\\"filter\\\": { } block.</p>\\n<p>You can combine filters inside queries, or queries inside filters too:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a match query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"match\\\": {\\n            \\\"title\\\": \\\"star\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Example of a bool query: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"term\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Another example:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d'\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match_phrase\\\": {\\\"title\\\": \\\"Star Wars\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 1980}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Phrase matching</h3>\\n<p>Must find all terms, in the right order: </p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": \\\"star wars\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>Assume order matters, but you're OK with some words being in between the terms. In that case use slop:</p>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase\\\": {\\n            \\\"title\\\": {\\\"query\\\": \\\"star beyond\\\", \\\"slop\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<p>The slop represents how far you're willing to let a term move to satisfy a phrase (in either direction!).</p>\\n<h3>Pagination</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"from\\\": 2,\\n    \\\"size\\\": 2,\\n    \\\"query\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}}\\n}'\\n</code></pre>\\n<h3>Sorting</h3>\\n<h3>More with filters</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"bool\\\": {\\n            \\\"must\\\": {\\\"match\\\": {\\\"genre\\\": \\\"Sci-Fi\\\"}},\\n            \\\"must_not\\\": {\\\"match\\\": {\\\"title\\\": \\\"trek\\\"}},\\n            \\\"filter\\\": {\\\"range\\\": {\\\"year\\\": {\\\"gte\\\": 2010, \\\"lt\\\": 2015}}}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Fuzzy queries</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"fuzzy\\\": {\\n            \\\"title\\\": {\\\"value\\\": \\\"intersteller\\\", \\\"fuzziness\\\": 1}\\n        }\\n    }\\n}'\\n</code></pre>\\n<h3>Partial matching</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"prefix\\\": {\\n            \\\"year\\\": \\\"201\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"wildcard\\\": {\\n            \\\"year\\\": \\\"1*\\\"\\n        }\\n    }\\n}'\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">curl -XDELETE 127.0.0.1:9200/movies\\n\\ncurl -XPUT 127.0.0.1:9200/movies -d '\\n{\\n    \\\"mappings\\\": {\\n        \\\"properties\\\": {\\n            \\\"year\\\": {\\n                \\\"type\\\": \\\"text\\\"\\n            }\\n        }\\n    }\\n}'\\n\\ncurl -XPUT 127.0.0.1:9200/_bulk --data-binary @movies.json\\n</code></pre>\\n<h3>Search as you type</h3>\\n<pre><code class=\\\"language-bash\\\">curl -XGET 127.0.0.1:9200/movies/_search?pretty -d '\\n{\\n    \\\"query\\\": {\\n        \\\"match_phrase_prefix\\\": {\\n            \\\"title\\\": {\\n                \\\"query\\\": \\\"star tr\\\",\\n                \\\"slop\\\": 10\\n            }\\n        }\\n    }\\n}'\\n</code></pre>\",\"id\":\"/home/nicolas/Documents/workshop/src/pages/2020-08-29-ELK-2/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2020-08-29T22:47:32.235Z\",\"path\":\"/elk-searching\",\"title\":\"Searching with Elasticsearch\",\"excerpt\":\"\",\"tags\":[\"Elastic Search\",\"searching\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/docker.json\n// module id = 381\n// module chunks = 174890689291889"],"sourceRoot":""}