{"version":3,"sources":["webpack:///path---idioms-68947c8d1f45e6a1bd1f.js","webpack:///./.cache/json/idioms.json"],"names":["webpackJsonp","435","module","exports","data","markdownRemark","html","frontmatter","title","date","path","tags","excerpt","pathContext","prev","id","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,GAAAC,aAAyBC,MAAA,iBAAAC,KAAA,gBAAAC,KAAA,UAAAC,MAAA,UAAAC,QAAA,MAAkGC,aAAgBC,MAAQR,KAAA,isQAAooOS,GAAA,0HAAAR,aAAowCE,KAAA,2BAAAC,KAAA,UAAAF,MAAA,UAAAI,QAAA,GAAAD,MAAA,4EAAqKK,MAASV,KAAA,mvJAA44BS,GAAA,mIAAAR,aAA6iIE,KAAA,2BAAAC,KAAA,mBAAAF,MAAA,kBAAAI,QAAA,GAAAD,MAAA","file":"path---idioms-68947c8d1f45e6a1bd1f.js","sourcesContent":["webpackJsonp([116647980945435],{\n\n/***/ 435:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"\",\"frontmatter\":{\"title\":\"English idioms\",\"date\":\"July 15, 2022\",\"path\":\"/idioms\",\"tags\":[\"idioms\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<p>The following few steps can be taken as a quick start to Argo CD\\nthat can be done with a local cluster, say minikube. </p>\\n<h2>Starting argocd non HA with cluster privilege</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n</code></pre>\\n<h2>Displaying argocd initial admin secret</h2>\\n<pre><code class=\\\"language-zsh\\\">ENCODED=$(kubectl -n argocd get secret argocd-initial-admin-secret -o yaml | yq .data.password)\\necho $ENCODED\\necho $ENCODED | base64 --decode\\n</code></pre>\\n<h2>Exposing argocd server with a port forward argocd server pod</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl port-forward svc/argocd-server -n argocd 8080:443\\n</code></pre>\\n<p>Open browser at <a href=\\\"https://localhost:8080\\\">https://localhost:8080</a></p>\\n<h2>Using ArgoCD CLI</h2>\\n<p>CLI allows to manage everything: applications, repos, clusters, tasks, projects...</p>\\n<pre><code class=\\\"language-zsh\\\">argocd login localhost:8080\\nargocd cluster list\\n</code></pre>\\n<h2>Applications</h2>\\n<p>Given the following yaml content in a file called <code>application.yml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>run the following commands:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application.yml\\n</code></pre>\\n<p>And then verify the application was created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get application -n argocd\\n</code></pre>\\n<p>Other app based on helm can be started the same way:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_helm_options.yml\\n</code></pre>\\n<p>where <code>application_helm_options.yml</code> has a content like:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: helm-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: helm-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: helm-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    helm:\\n      releaseName: my-release\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Finally, an application loaded recursively from\\na local directory can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_subdirectories_options.yml\\n</code></pre>\\n<p>with a file <code>application_subdirectories_options.yml</code>\\nwith a content:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: directory-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: directory-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Here are ArgoCD options which can be adjusted with kustomize:</p>\\n<ul>\\n<li>Name prefix: appended to resources</li>\\n<li>Name suffix: appended to resources</li>\\n<li>Images: to override images</li>\\n<li>Common labels: set labels on all resources</li>\\n<li>Common annotations: set annotations on all resources</li>\\n<li>Version: explicitly set kustomize version</li>\\n</ul>\\n<p>The manifest below called for instance <code>application_kustomize.yaml</code> is an example of an kustomize argocd application. Two options are adjusted with kustomize: namePrefix\\nand a commonLabel with a key of app and a value of demo. </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: kustomize-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: kustomize-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: kustomize-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    kustomize:\\n      namePrefix: staging-\\n      commonLabels:\\n        app: demo\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Application can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_kustomize.yml\\n</code></pre>\\n<p>Note that Argo CD automatically detects that\\nit is a Kustomize application.</p>\\n<h2>Projects</h2>\\n<p>Display info on by default project:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>Now a project can be created by running </p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f ./project.yaml\\n</code></pre>\\n<p>with a file called project.yaml: </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: demo-project\\n  namespace: argocd\\nspec:\\n  description: Demo Project\\n  sourceRepos:\\n  - '*'\\n\\n  destinations:\\n  - namespace: '*'\\n    server: '*'\\n\\n  clusterResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n\\n  namespaceResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n</code></pre>\\n<p>Display info on projects again with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>An application can be defined to start in the project thus created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f './application.yml'\\n</code></pre>\\n<p>with the following content for application.yml:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook-demo-project\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook-demo-project\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: demo-project\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<h2>Sync</h2>\\n<p>Automated syncing can be enabled by declaring a syncPolicy in the\\nmanifest of the application. Or by adding a <code>sync-policy automated</code>\\nflag to a cli <code>argocd app create</code> command. There is also a\\nSYNC POLICY setting which can be set to Automatic in the Web UI.</p>\\n<p>Example of an application manifest:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: auto-sync-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: auto-sync-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    automated: {}\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<ul>\\n<li>\\n<p>Additional features: </p>\\n<ul>\\n<li>automated pruning</li>\\n<li>self healing</li>\\n</ul>\\n</li>\\n<li>\\n<p>Sync Options with at the resource level with annotations or at the\\napplication level with syncOptions (in syncPolicy):</p>\\n<ul>\\n<li>Prune = false</li>\\n<li>Validate = false</li>\\n</ul>\\n</li>\\n<li>\\n<p>Selective syncing at the application level only with syncOptions:\\nApplyOutOfSyncOnly=true</p>\\n</li>\\n<li>\\n<p>Argo waves with PruneLast=true at application or resource level.</p>\\n</li>\\n<li>\\n<p>Replacing resources: by default Argo CD uses <code>kubectl apply</code> to\\ndeploy resources changes\\nIn some cases, you need to replace/recreate the resources.\\nArgoCD can do this by using replace=true. It can be done at application level\\nwith a Replace of true in syncOptions. It can be also done at resource level\\nwith an annotation like <code>argocd.argoproj.io/sync-options: Replace=true</code></p>\\n</li>\\n<li>\\n<p>sync can be configured to fail if resource is found in other applications\\nby using FailOnSharedResource=true</p>\\n</li>\\n</ul>\",\"id\":\"/Users/nicolas/repos/github.com/nperon/workshop/src/pages/2022-08-14-argocd/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-08-14T22:51:00.823Z\",\"path\":\"/argocd\",\"title\":\"Argo CD\",\"excerpt\":\"\",\"tags\":[\"continuous delivery\",\"cloud\",\"devops\",\"gitops\",\"kubernetes\",\"kustomize\"]}},\"next\":{\"html\":\"<h2>Basic commands</h2>\\n<pre><code class=\\\"language-bash\\\">docker info\\ndocker\\n</code></pre>\\n<h2>Containers</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run --publish 80:80 --detach --name webhost nginx\\ndocker container logs webhost\\ndocker container stop webhost\\ndocker container top webhost\\ndocker container ls -a\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --publish 3306:3306 --name db --env MYSQL_RANDOM_ROOT_PASSWORD=yes mysql\\ndocker container logs db\\ndocker container inspect db\\ndocker container stats db\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run -it --name proxy nginx bash\\n</code></pre>\\n<h2>Networks</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run -p 80:80 --name webhost --detach nginx\\ndocker container port webhost\\ndocker container inspect --format '{{ .NetworkSettings.IPAddress }}' webhost\\nifconfig\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker network ls\\ndocker network inspect bridge\\ndocker network create my_app_net\\ndocker network inspect my_app_net\\ndocker container run --detach --name new_nginx --network my_app_net nginx\\ndocker network inspect my_app_net\\ndocker network connect my_app_net webhost\\ndocker container inspect webhost\\ndocker network disconnect my_app_net webhost\\ndocker container inspect webhost\\n</code></pre>\\n<h2>DNS</h2>\\n<pre><code class=\\\"language-bash\\\">docker network inspect my_app_net\\ndocker container run --detach --name my_nginx --network my_app_net nginx:alpine\\ndocker network inspect my_app_net\\ndocker container exec -it my_nginx ping new_nginx\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker network create dude\\ndocker container run --detach --network dude --network-alias search elasticsearch:2\\ndocker container run --detach --network dude --network-alias search elasticsearch:2\\ndocker container run --rm --network dude alpine nslookup search\\ndocker container run --rm --network dude centos curl -s search:9200\\ndocker container run --rm --network dude centos curl -s search:9200\\n</code></pre>\\n<h2>Images</h2>\\n<pre><code class=\\\"language-bash\\\">docker history nginx:latest\\ndocker image inspect nginx:latest\\n\\ndocker image tag nginx nperon/nginx\\ndocker login\\ncat ~/.docker/config.json\\ndocker logout\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">cd dockerfile-sample-1/\\n\\ndocker build -t nperon/nodeapp .\\ndocker container run --rm --publish 80:3000 --detach nperon/nodeapp\\ndocker push nperon/nodeapp\\n</code></pre>\\n<h2>Using Prune to Keep Your Docker System Clean</h2>\\n<p>Command to see space usage:</p>\\n<pre><code class=\\\"language-bash\\\">docker system df\\n</code></pre>\\n<p>Command to clean up just dangling images:</p>\\n<pre><code class=\\\"language-bash\\\">docker image prune\\n</code></pre>\\n<p>Command to clean up everything: </p>\\n<pre><code class=\\\"language-bash\\\">docker system prune\\n</code></pre>\\n<p>Command to remove all unused images: </p>\\n<pre><code class=\\\"language-bash\\\">docker image prune -a\\n</code></pre>\\n<p>Command to check the size of each running container: </p>\\n<pre><code class=\\\"language-bash\\\">docker ps --size\\n</code></pre>\\n<p>Command to delete all containers: </p>\\n<pre><code class=\\\"language-bash\\\">docker rm -f $(docker ps -a -q)\\n</code></pre>\\n<p>Command to delete all volumes: </p>\\n<pre><code class=\\\"language-bash\\\">docker volume rm $(docker volume ls -q)\\n</code></pre>\\n<h2>Persistent Data: Data Volumes</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True mysql\\n\\ndocker container run --detach --name mysql3 -e MYSQL_ALLOW_EMPTY_PASSWORD=True -v mysql-db:/var/lib/mysql mysql\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --name psql -v psql-data:/var/lib/postgresql/data postgres:9.6.1\\ndocker container logs -f psql\\n</code></pre>\\n<h2>Persistent Data: Bind Mounting</h2>\\n<pre><code class=\\\"language-bash\\\">cd dockerfile-sample-2\\ndocker container run -d --name nginx -p 80:80 -v $(pwd):/usr/share/nginx/html nginx\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">cd bindmount-sample-1\\ndocker run -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve\\n</code></pre>\\n<h2>docker-compose</h2>\\n<h3>Structure of docker-compose yml</h3>\\n<pre><code class=\\\"language-yml\\\">version: '3.2'  # if no version is specified then v1 is assumed. Recommend v2 minimum\\n\\nservices:  # containers. same as docker run\\n  servicename: # a friendly name. this is also DNS name inside network\\n    image: # Optional if you use build:\\n    command: # Optional, replace the default CMD specified by the image\\n    environment: # Optional, same as -e in docker run\\n    volumes: # Optional, same as -v in docker run\\n  servicename2:\\n\\nvolumes: # Optional, same as docker volume create\\n\\nnetworks: # Optional, same as docker network create\\n</code></pre>\",\"id\":\"/Users/nicolas/repos/github.com/nperon/workshop/src/pages/2021-05-16-docker-concepts/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2021-05-16T22:21:00.451Z\",\"path\":\"/docker-concepts\",\"title\":\"Docker concepts\",\"excerpt\":\"\",\"tags\":[\"Docker\",\"containers\",\"networks\",\"images\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---idioms-68947c8d1f45e6a1bd1f.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"\",\"frontmatter\":{\"title\":\"English idioms\",\"date\":\"July 15, 2022\",\"path\":\"/idioms\",\"tags\":[\"idioms\"],\"excerpt\":\"\"}}},\"pathContext\":{\"prev\":{\"html\":\"<p>The following few steps can be taken as a quick start to Argo CD\\nthat can be done with a local cluster, say minikube. </p>\\n<h2>Starting argocd non HA with cluster privilege</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n</code></pre>\\n<h2>Displaying argocd initial admin secret</h2>\\n<pre><code class=\\\"language-zsh\\\">ENCODED=$(kubectl -n argocd get secret argocd-initial-admin-secret -o yaml | yq .data.password)\\necho $ENCODED\\necho $ENCODED | base64 --decode\\n</code></pre>\\n<h2>Exposing argocd server with a port forward argocd server pod</h2>\\n<pre><code class=\\\"language-zsh\\\">kubectl port-forward svc/argocd-server -n argocd 8080:443\\n</code></pre>\\n<p>Open browser at <a href=\\\"https://localhost:8080\\\">https://localhost:8080</a></p>\\n<h2>Using ArgoCD CLI</h2>\\n<p>CLI allows to manage everything: applications, repos, clusters, tasks, projects...</p>\\n<pre><code class=\\\"language-zsh\\\">argocd login localhost:8080\\nargocd cluster list\\n</code></pre>\\n<h2>Applications</h2>\\n<p>Given the following yaml content in a file called <code>application.yml</code>:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>run the following commands:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application.yml\\n</code></pre>\\n<p>And then verify the application was created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get application -n argocd\\n</code></pre>\\n<p>Other app based on helm can be started the same way:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_helm_options.yml\\n</code></pre>\\n<p>where <code>application_helm_options.yml</code> has a content like:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: helm-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: helm-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: helm-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    helm:\\n      releaseName: my-release\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Finally, an application loaded recursively from\\na local directory can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_subdirectories_options.yml\\n</code></pre>\\n<p>with a file <code>application_subdirectories_options.yml</code>\\nwith a content:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: directory-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: directory-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Here are ArgoCD options which can be adjusted with kustomize:</p>\\n<ul>\\n<li>Name prefix: appended to resources</li>\\n<li>Name suffix: appended to resources</li>\\n<li>Images: to override images</li>\\n<li>Common labels: set labels on all resources</li>\\n<li>Common annotations: set annotations on all resources</li>\\n<li>Version: explicitly set kustomize version</li>\\n</ul>\\n<p>The manifest below called for instance <code>application_kustomize.yaml</code> is an example of an kustomize argocd application. Two options are adjusted with kustomize: namePrefix\\nand a commonLabel with a key of app and a value of demo. </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: kustomize-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: kustomize-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: kustomize-guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    kustomize:\\n      namePrefix: staging-\\n      commonLabels:\\n        app: demo\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<p>Application can be started with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f application_kustomize.yml\\n</code></pre>\\n<p>Note that Argo CD automatically detects that\\nit is a Kustomize application.</p>\\n<h2>Projects</h2>\\n<p>Display info on by default project:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>Now a project can be created by running </p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f ./project.yaml\\n</code></pre>\\n<p>with a file called project.yaml: </p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: AppProject\\nmetadata:\\n  name: demo-project\\n  namespace: argocd\\nspec:\\n  description: Demo Project\\n  sourceRepos:\\n  - '*'\\n\\n  destinations:\\n  - namespace: '*'\\n    server: '*'\\n\\n  clusterResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n\\n  namespaceResourceWhitelist:\\n  - group: '*'\\n    kind: '*'\\n</code></pre>\\n<p>Display info on projects again with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl get appproject -n argocd -o yaml\\n</code></pre>\\n<p>An application can be defined to start in the project thus created with:</p>\\n<pre><code class=\\\"language-zsh\\\">kubectl apply -f './application.yml'\\n</code></pre>\\n<p>with the following content for application.yml:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook-demo-project\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: guestbook-demo-project\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: demo-project\\n  source:\\n    path: guestbook\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n  syncPolicy:\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<h2>Sync</h2>\\n<p>Automated syncing can be enabled by declaring a syncPolicy in the\\nmanifest of the application. Or by adding a <code>sync-policy automated</code>\\nflag to a cli <code>argocd app create</code> command. There is also a\\nSYNC POLICY setting which can be set to Automatic in the Web UI.</p>\\n<p>Example of an application manifest:</p>\\n<pre><code class=\\\"language-yaml\\\">apiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: auto-sync-app\\n  namespace: argocd\\nspec: \\n  destination:\\n    namespace: auto-sync-app\\n    server: \\\"https://kubernetes.default.svc\\\"\\n  project: default\\n  source:\\n    path: guestbook-with-sub-directories\\n    repoURL: \\\"https://github.com/mabusaa/argocd-example-apps.git\\\"\\n    targetRevision: master\\n    directory:\\n      recurse: true\\n  syncPolicy:\\n    automated: {}\\n    syncOptions:\\n      - CreateNamespace=true\\n</code></pre>\\n<ul>\\n<li>\\n<p>Additional features: </p>\\n<ul>\\n<li>automated pruning</li>\\n<li>self healing</li>\\n</ul>\\n</li>\\n<li>\\n<p>Sync Options with at the resource level with annotations or at the\\napplication level with syncOptions (in syncPolicy):</p>\\n<ul>\\n<li>Prune = false</li>\\n<li>Validate = false</li>\\n</ul>\\n</li>\\n<li>\\n<p>Selective syncing at the application level only with syncOptions:\\nApplyOutOfSyncOnly=true</p>\\n</li>\\n<li>\\n<p>Argo waves with PruneLast=true at application or resource level.</p>\\n</li>\\n<li>\\n<p>Replacing resources: by default Argo CD uses <code>kubectl apply</code> to\\ndeploy resources changes\\nIn some cases, you need to replace/recreate the resources.\\nArgoCD can do this by using replace=true. It can be done at application level\\nwith a Replace of true in syncOptions. It can be also done at resource level\\nwith an annotation like <code>argocd.argoproj.io/sync-options: Replace=true</code></p>\\n</li>\\n<li>\\n<p>sync can be configured to fail if resource is found in other applications\\nby using FailOnSharedResource=true</p>\\n</li>\\n</ul>\",\"id\":\"/Users/nicolas/repos/github.com/nperon/workshop/src/pages/2022-08-14-argocd/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2022-08-14T22:51:00.823Z\",\"path\":\"/argocd\",\"title\":\"Argo CD\",\"excerpt\":\"\",\"tags\":[\"continuous delivery\",\"cloud\",\"devops\",\"gitops\",\"kubernetes\",\"kustomize\"]}},\"next\":{\"html\":\"<h2>Basic commands</h2>\\n<pre><code class=\\\"language-bash\\\">docker info\\ndocker\\n</code></pre>\\n<h2>Containers</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run --publish 80:80 --detach --name webhost nginx\\ndocker container logs webhost\\ndocker container stop webhost\\ndocker container top webhost\\ndocker container ls -a\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --publish 3306:3306 --name db --env MYSQL_RANDOM_ROOT_PASSWORD=yes mysql\\ndocker container logs db\\ndocker container inspect db\\ndocker container stats db\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run -it --name proxy nginx bash\\n</code></pre>\\n<h2>Networks</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run -p 80:80 --name webhost --detach nginx\\ndocker container port webhost\\ndocker container inspect --format '{{ .NetworkSettings.IPAddress }}' webhost\\nifconfig\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker network ls\\ndocker network inspect bridge\\ndocker network create my_app_net\\ndocker network inspect my_app_net\\ndocker container run --detach --name new_nginx --network my_app_net nginx\\ndocker network inspect my_app_net\\ndocker network connect my_app_net webhost\\ndocker container inspect webhost\\ndocker network disconnect my_app_net webhost\\ndocker container inspect webhost\\n</code></pre>\\n<h2>DNS</h2>\\n<pre><code class=\\\"language-bash\\\">docker network inspect my_app_net\\ndocker container run --detach --name my_nginx --network my_app_net nginx:alpine\\ndocker network inspect my_app_net\\ndocker container exec -it my_nginx ping new_nginx\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker network create dude\\ndocker container run --detach --network dude --network-alias search elasticsearch:2\\ndocker container run --detach --network dude --network-alias search elasticsearch:2\\ndocker container run --rm --network dude alpine nslookup search\\ndocker container run --rm --network dude centos curl -s search:9200\\ndocker container run --rm --network dude centos curl -s search:9200\\n</code></pre>\\n<h2>Images</h2>\\n<pre><code class=\\\"language-bash\\\">docker history nginx:latest\\ndocker image inspect nginx:latest\\n\\ndocker image tag nginx nperon/nginx\\ndocker login\\ncat ~/.docker/config.json\\ndocker logout\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">cd dockerfile-sample-1/\\n\\ndocker build -t nperon/nodeapp .\\ndocker container run --rm --publish 80:3000 --detach nperon/nodeapp\\ndocker push nperon/nodeapp\\n</code></pre>\\n<h2>Using Prune to Keep Your Docker System Clean</h2>\\n<p>Command to see space usage:</p>\\n<pre><code class=\\\"language-bash\\\">docker system df\\n</code></pre>\\n<p>Command to clean up just dangling images:</p>\\n<pre><code class=\\\"language-bash\\\">docker image prune\\n</code></pre>\\n<p>Command to clean up everything: </p>\\n<pre><code class=\\\"language-bash\\\">docker system prune\\n</code></pre>\\n<p>Command to remove all unused images: </p>\\n<pre><code class=\\\"language-bash\\\">docker image prune -a\\n</code></pre>\\n<p>Command to check the size of each running container: </p>\\n<pre><code class=\\\"language-bash\\\">docker ps --size\\n</code></pre>\\n<p>Command to delete all containers: </p>\\n<pre><code class=\\\"language-bash\\\">docker rm -f $(docker ps -a -q)\\n</code></pre>\\n<p>Command to delete all volumes: </p>\\n<pre><code class=\\\"language-bash\\\">docker volume rm $(docker volume ls -q)\\n</code></pre>\\n<h2>Persistent Data: Data Volumes</h2>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD=True mysql\\n\\ndocker container run --detach --name mysql3 -e MYSQL_ALLOW_EMPTY_PASSWORD=True -v mysql-db:/var/lib/mysql mysql\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">docker container run --detach --name psql -v psql-data:/var/lib/postgresql/data postgres:9.6.1\\ndocker container logs -f psql\\n</code></pre>\\n<h2>Persistent Data: Bind Mounting</h2>\\n<pre><code class=\\\"language-bash\\\">cd dockerfile-sample-2\\ndocker container run -d --name nginx -p 80:80 -v $(pwd):/usr/share/nginx/html nginx\\n</code></pre>\\n<pre><code class=\\\"language-bash\\\">cd bindmount-sample-1\\ndocker run -p 80:4000 -v $(pwd):/site bretfisher/jekyll-serve\\n</code></pre>\\n<h2>docker-compose</h2>\\n<h3>Structure of docker-compose yml</h3>\\n<pre><code class=\\\"language-yml\\\">version: '3.2'  # if no version is specified then v1 is assumed. Recommend v2 minimum\\n\\nservices:  # containers. same as docker run\\n  servicename: # a friendly name. this is also DNS name inside network\\n    image: # Optional if you use build:\\n    command: # Optional, replace the default CMD specified by the image\\n    environment: # Optional, same as -e in docker run\\n    volumes: # Optional, same as -v in docker run\\n  servicename2:\\n\\nvolumes: # Optional, same as docker volume create\\n\\nnetworks: # Optional, same as docker network create\\n</code></pre>\",\"id\":\"/Users/nicolas/repos/github.com/nperon/workshop/src/pages/2021-05-16-docker-concepts/index.md absPath of file >>> MarkdownRemark\",\"frontmatter\":{\"date\":\"2021-05-16T22:21:00.451Z\",\"path\":\"/docker-concepts\",\"title\":\"Docker concepts\",\"excerpt\":\"\",\"tags\":[\"Docker\",\"containers\",\"networks\",\"images\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/idioms.json\n// module id = 435\n// module chunks = 116647980945435"],"sourceRoot":""}